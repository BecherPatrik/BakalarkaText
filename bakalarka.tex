%%%  Ukázkový text a dokumentace stylu pro text závěrečné (bakalářské a
%%%  diplomové) práce na KI PřF UP v Olomouci
%%%  Copyright (C) 2012 Martin Rotter, <rotter.martinos@gmail.com>
%%%  Copyright (C) 2014 Jan Outrata, <jan.outrata@upol.cz>


%%  Pro získání PDF souboru dokumentu je třeba tento zdrojový text v
%%  LaTeXu přeložit (dvakrát) programem pdfLaTeX.

%%  V případě použití programu BibLaTeX pro tvorbu seznamu literatury
%%  je poté ještě třeba spustit program Biber s parametrem jméno
%%  souboru zdrojového textu bez přípony a následně opět (dvakrát)
%%  přeložit zdrojový text programem pdfLaTeX.

%%  Postup získání Postscriptového souboru je popsán v dokumentaci.


%%  Třída dokumentu implementující styl pro závěrečnou práci. Vybrané
%%  nepovinné parametry (ostatní v dokumentaci):

%%  'master' pro sazbu diplomové práce, jinak se sází bakalářská práce

%%  'field=kód' pro Váš studijní obor, kódy pro diplomovou práci 'uvt'
%%  pro Učitelství výpočetní techniky pro střední školy a 'binf' pro
%%  Bioinformatiku, jinak je výchozí Informatika, a pro bakalářskou
%%  práci 'ainfk' pro Aplikovanou informatiku v kombinované formě,
%%  'inf' pro Informatiku, 'infv' pro Informatiku pro vzdělávání a
%%  'binf' pro Bioinfomatiku, jinak je výchozí Aplikovaná informatika
%%  v prezenční formě

%%  'printversion' pro sazbu verze pro tisk (nebarevné logo a odkazy,
%%  odkazy s uvedením adresy za odkazem, ne odkazy do rejstříku),
%%  jinak verze pro prohlížeč

%%  'biblatex' pro zapnutí podpory pro sazbu bibliografie pomocí
%%  BibLaTeXu, jinak je výchozí sazba v prostředí thebibliography

%%  'language=jazyk' pro jazyk práce, jazyky english pro anglický,
%%  slovak pro slovenský, jinak je výchozí czech pro český

%%  'font=sans' pro bezpatkový font (Iwona Light), jinak výchozí
%%  patkový (Latin Modern)

\documentclass[
%  master,
%  field=inf,
%  printversion,
  biblatex=false,
%  language=english,
  font=serif,
  glossaries=false,
  tables=false,
  theorems=false,
  index
]{kidiplom}

\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother

\usepackage[section]{placeins}

%% Informace pro úvodní strany. V jazyku práce (pokud není v komentáři
%% uvedeno česky) a anglicky. Uveďte všechny, u kterých není v
%% komentáři uvedeno, že jsou volitelné. Při neuvedení se použijí
%% výchozí texty. Text pro jiný než nastavený jazyk práce (nepovinným
%% parametrem language makra \documentclass, výchozí český) se zadává
%% použitím makra s uvedením jazyka jako nepovinného parametru.

%% Název práce, česky a anglicky. Měl by se vysázet na jeden řádek.
\title{Demonstrace práce s datovými strukturami}
\title[english]{Data Structure Demonstration}

%% Volitelný podnázev práce, česky a anglicky. Měl by se vysázet na
%% jeden řádek. Výchozí je prázdný.
%% \subtitle{Demonstrace práce s datovými strukturami}
%% \subtitle[english]{Data Structure Demonstration}

%% Jméno autora práce. Makro nemá nepovinný parametr pro uvedení
%% jazyka.
\author{Patrik Becher}

%% Jméno vedoucího práce (včetně titulů). Makro nemá nepovinný
%% parametr pro uvedení jazyka.
\supervisor{Mgr. Tomáš Kühr, Ph.D.}

%% Volitelný rok odevzdání práce. Výchozí je aktuální (kalendářní)
%% rok. Makro nemá nepovinný parametr pro uvedení jazyka.
%\yearofsubmit{\the\year}

%% Anotace práce, včetně anglické (obvykle překlad z jazyka
%% práce). Jeden odstavec!
\annotation{Cílem bakalářské práce bylo vytvořit program pro podporu výuky algoritmizace, konkrétně práce se základními stromovými datovými strukturami (binární vyhledávací stromy, AVL stromy, červeno-černé stromy). Výsledná aplikace podporuje vizualizaci vybraných datových struktur, včetně názorné demonstrace běžně prováděných operací s těmito datovými strukturami se souběžným zobrazením pseudokódu prováděné operace.}

\annotation[english]{The main goal of my bachelor thesis was to create a program as a teaching support for algorithms, work with basic tree structures (binary search trees, AVL trees, red-black trees) in particular. Final program supports visualization of selected data structures, including illustrative demonstrations commonly performed operations with these data structures with parallel pseudocode imaging of performed operations.}

%% Klíčová slova práce, včetně anglických. Oddělená (obvykle) středníkem.
\keywords{Binární vyhledávací strom, Binární strom, AVL strom, Červeno-černý strom}
\keywords[english]{Binary search tree, Binary tree, AVL tree, Red-black tree}

%% Volitelná specifikace příloh textu práce, i anglicky. Výchozí je '1
%% CD/DVD'.
%\supplements{jedno kulaté placaté CD/DVD s malou kulatou dírou uprostřed}
%\supplements[english]{one round flat CD/DVD with a small round hole in the middle}

%% Poděkování. Stručné!
\thanks{Rád bych poděkoval panu Mgr. Tomáši Kührovi Ph.D. za vedení této bakalářské práce a panu RNDr. Arnoštu Večerkovi za odbornou pomoc a poskytnuté materiály k práci. Dále bych chtěl poděkovat mé rodině a přítelkyni za podporu při tvorbě.}

%% Další dodatečné styly (balíky) potřebné pro sazbu vlastního textu práce.
\usepackage{lipsum}

%% Balíčky pro implementaci seznamů vedle sebe.
\usepackage{amssymb}
\usepackage{enumitem}

%-------------------------------------------------------------
% TODO: Nebylo by špatné barvy a
% zvýraznění syntaxe jazyka GLSL přesunout do
% samostatného souboru.
\usepackage{color}

%-------------------------------------------------------------
% Nadefinuj barvy
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%-------------------------------------------------------------
% Nadefinuj zvýraznění syntaxe pro jazyk Pseudo
% TODO: 1) Definice není úplně čistá.
%            2) Přesuň tuto definici do vlastního souboru.
\lstdefinelanguage{Pseudo}
{
  sensitive=false, % keywords are not case-sensitive
  keywords={define, end, return, while, do, if, then, else, elseif, for, to, do, end, relief, paraOcc, loadSample},
  morekeywords={},
  %alsoletter=\#\_, % now I can use # character in keywords
  keywordstyle=\bfseries\color{black}, % style of keywords
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab 
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  %numbers=left, % show line numbers at the left
  %numberstyle=\ttfamily, % style of the line numbers
  backgroundcolor=\color{backcolour},
  basicstyle=\small\color{black},
  commentstyle=\color{green}, % style of comments
  stringstyle=\color{black}, % style of strings
  morecomment=[l]{//}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
  moredelim=[is][\bfseries]{/@}{@/}
}
%-------------------------------------------------------------

% \noindent pro cely dokument.
% \setlength{\parindent}{0pt}

%-------------------------------------------------------------
\begin{document}
%% Sazba úvodních stran -- titulní, s bibliografickými údaji, s
%% anotací a klíčovými slovy, s poděkováním a prohlášením, s obsahem a
%% se seznamy obrázků, tabulek, vět a zdrojových kódů (pokud jejich
%% sazba není vypnutá).

%-------------------------------------------------------------
% Strany 1 - 6

\maketitle

%% Vlastní text závěrečné práce. Pro povinné závěry, před přílohami,
%% použijte prostředí kiconclusions. Povinná je i příloha s obsahem
%% přiloženého CD/DVD.

%-------------------------------------------------------------
% Strana 7

\section{Úvod}
\indent\indent Tato aplikace vznikla za účelem výuky základních binárních stromů. Obsahuje podporu pro \textit{Binární vyhledávací}, \textit{AVL} a \textit{Červenočerné stromy}. Tyto stromy jsem vybral ze seznamu stromů zmíněných v zadání bakalářské práce. Kvůli časové náročnosti implementace a testování animací těchto stromů, jsem byl bohužel nucen opustit od původní koncepce programu, který byl navržen na podporu všech zmíněných datových struktur.\\
\indent Program pomocí animací zobrazuje operace: \textit{Vyhledávání}, \textit{Vkládání} a \textit{Odebírání} prvků ze stromů. Souběžně s animací zobrazuje stručný pseudokód aktuálně prováděné operace. Dále umožňuje \textit{opakovat poslední operaci}, \textit{ukládat a načítat stromy}, \textit{exportovat strom do obrázku} a \textit{generovat stromy s náhodnými prvky}.\\
\indent Datová struktura \textit{strom} je v informatice velmi často využívána, hlavně jako způsob ukládání dat, kde má následné vyhledávání velmi dobrou časovou složitost. Kvůli této skutečnosti je důležité, aby každý programátor tyto struktury znal. K samotnému pochopení těchto stromů jsem i já osobně využíval různé programy, které umožňovaly graficky vytvářet a provádět operace s těmito stromy. To byla pro mě motivace, abych si vybral bakalářskou práci na toto téma a mohl vytvořit obdobnou aplikaci jako ty, které jsem používal při učení. \\
\indent Text samotné práce se dělí na tři části: \textit{teoretickou část} -- zabývá se teorií vybraných stromů, \textit{programovací část} -- popisuje architekturu a samotnou implementaci programu, a \textit{část s uživatelskou příručkou} --  zde je vysvětleno uživatelské prostředí a funkcionalita.\\
\newpage
\section{Stromy}
\indent \indent V kapitole jsou vysvětleny základní pojmy, které jsou nezbytné k pochopení vlastností \textit{stromů} obsažených v aplikaci. V podkapitolách jsou osvětleny principy pro tvorbu a následnou práci s konkrétními \textit{binárními stromy}. Využitím těchto principů byl naprogramován tento výukový nástroj.\\ 
\indent Kapitola včetně podkapitol vychází z publikací \cite{belohlavekALM}, \cite{belohlavekVychodil}, \cite{vecerka}, \cite{dvorsky}, \cite{BinarySearch}, \cite{Adelson} a \cite{cormen}.


\begin{definition}[Strom]
\indent \textit{Strom} je neorientovaný \footnote{Mezi každými dvěma vrcholy existuje právě jedna cesta.} souvislý \footnote{Vynecháním libovolné hrany vznikne nesouvislý graf.} graf bez kružnic \footnote{Přidáním jakékoli hrany vznikne graf s kružnicí.} \cite{belohlavekALM}.
\end{definition}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.6]{obrazky/1Stromy.png}
	\caption{Příklady neorientovaných stromů}
\end{figure}

\medskip
\noindent Strom je datová struktura, která představuje stromovou strukturu propojených \textit{uzlů} \footnote{Prvek obsahující hodnotu.}. Uzly jsou mezi sebou vzájemně spojeny pomocí \textit{hran} \footnote{Představuje cestu mezi spojenými uzly.}. Strom složený z uzlů $U$ má $|U - 1|$ hran.


\begin{definition}[Kořenový strom]
\indent \textit{Kořenový strom} je strom, ve kterém je vybrán jeden vrchol (kořen). Může to být kterýkoliv vrchol. Bývá to ale vrchol, který je v nějakém smyslu na vrcholu hierarchie objektů, která je stromem reprezentována.
\cite{belohlavekALM}
\end{definition}
\smallskip

\newpage
\noindent \textbf{Důležité pojmy:}
\begin{itemize}
\item \textbf{Uzel} -- Jednoduše jakýkoliv prvek stromu.
\item \textbf{Kořen} -- Jeden konkrétní uzel, který se nachází na vrcholu stromu. Pouze tento uzel nemá \textit{rodiče}. 
\item \textbf{Potomek, následník} -- Uzel, který je hranou přímo připojen k jinému uzlu, cestou od kořene.
\item \textbf{Rodič, předchůdce} -- Uzel, který má alespoň jednoho potomka.
\item \textbf{Sourozenci} -- Skupina uzlů, které mají stejného rodiče.
\item \textbf{Podstrom} -- Část stromu, která je úplným stromem s tím, že kořen tohoto podstromu má svého rodiče.
\item \textbf{Koncový uzel, list} -- Uzel bez potomků. 
\item \textbf{Výška stromu} -- Nejdelší délka cesty od kořene k uzlu.
\end{itemize} 

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.6]{obrazky/2PopisStromu.png}
	\caption{Popis struktury stromu}
\end{figure}

\begin{definition}[$m$-ární stromy]
Kořenový strom se nazývá $m$\textit{-ární}, právě když každý jeho vrchol má nejvýše $m$ potomků. 2-ární strom se nazývá binární. Kořenový strom se nazývá úplný $m$\textit{-ární}, právě když každý jeho vrchol nemá buď žádného nebo má právě $m$ potomků.\cite{belohlavekVychodil}
\end{definition}
\smallskip

\subsection{Binární strom}
\begin{definition}[Binární strom]
\textit{Binární strom} je typ kořenových stromů, ve kterém každý obsažený uzel má maximálně 2 potomky.
\end{definition}
\smallskip

\noindent\textbf{Každý uzel obsahuje vlastnosti:}
\begin{itemize}
\item \textbf{Klíč} -- Hodnota uložená v uzlu.
\item \textbf{Ukazatel na levého potomka}
\item \textbf{Ukazatel na pravého potomka}
\item \textbf{Ukazatel na jednoho rodiče} -- Tento ukazatel není povinný.
\end{itemize}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.9]{obrazky/3BinarniStrom.png}
	\caption{Příklad zobrazení binárního stromu}
\end{figure}


\medskip
\subsection{Binární vyhledávací strom}
\indent\indent Binární \textit{vyhledávací} strom (zkratka BVS) je speciální typ binárního stromu, kde platí následující:
\begin{itemize}
\item \textbf {Každý \textit{pravý} potomek $P$ rodiče $R$ má vyšší hodnotu $h$ než jeho rodič.} Platí tedy: $P.h > R.h$ $\Rightarrow$ Pravý podstrom uzlu $R$ obsahuje pouze uzly, které mají vyšší hodnotu než uzel $R$. 
\item \textbf {Každý \textit{levý} potomek $L$ rodiče $R$ má nižší hodnotu $h$ než jeho rodič.} Platí tedy: $P.h > L.h$ $\Rightarrow$ Levý podstrom uzlu $R$ obsahuje pouze uzly, které mají nižší hodnotu než uzel $R$. 
\item \textbf {Ve stromě se nenachází dva uzly se stejnou hodnotou.}
\end{itemize} 

\noindent Toto uspořádání uzlů v BVS usnadňuje vyhledávání. Operace nad BVS stromem s výškou \textit{h}  mají časovou složitost $ \theta$(\textit{h}). V nejhorším případě může mít BVS výšku rovnu \textit{n} - 1, kde \textit{n} je počet uzlů. Oba případy jsou zobrazeny na obrázku \ref{binary}.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.7]{obrazky/4BinarniVyhledavaciStrom.png}
	\caption{BVS - stejné hodnoty, ale rozdílná výška }
	\label{binary}
\end{figure}

\subsubsection{Vyhledávání}
\indent\indent Operace \textit{vyhledávání} patří k nejčastěji používané operaci s BVS. Při \textit{vyhledávání} je potřeba zadat hodnotu $x$, kterou chceme vyhledat. Postupně dochází k porovnávání hodnot uzlů s $x$. Výsledkem vyhledávání je buď uzel, který obsahuje hodnotu $x$ nebo takový uzel neexistuje.\\

\noindent \textbf{Přesný postup vyhledávání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Na začátku vyhledávání je třeba určit aktuální uzel, který označíme $u$. Hledanou hodnotu označíme $x$.\\
V tomto kroku $u$ bude kořen stromu, pokud strom nemá kořen, hodnota $x$ je nenalezena a tím vyhledávání končí.
{\bfseries\item  krok} -- průběžný \\
Zde dochází k porovnávání $x$ a hodnoty aktuálního uzlu $u$. Hodnotu $u$ označíme $u.h$.\\
Pokud je $u$ prázdný, vyhledávání končí neúspěchem. \\\\
\textbf{Při porovnávání mohou nastat tyto možnosti:}
\begin{itemize}
\item $x > u.h$ \\
V tomto případě jako $u$ nastavíme pravého potomka $u$. A znovu provedeme 2. krok.
\newpage
\item $x < u.h$\\
V tomto případě jako $u$ nastavíme levého potomka $u$. A znovu provedeme 2. krok.
\item $x = u.h$\\
Hledaná hodnota $x$ byla nalezena v $u$. Vyhledávání tedy končí.
\end{itemize}
\end{enumerate}

\medskip
\noindent Na obrázku \ref{binarySearch} je zvýrazněna cesta průchodů stromem při vyhledávání uzlu s hodnotou 5. Na obrázku je i zaznamenána historie porovnávání.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.9]{obrazky/5BinarniVyhledavani.png}
	\caption{BVS - postup vyhledávání hodnoty 5}
	\label{binarySearch}
\end{figure}

\medskip \medskip \medskip
\noindent \textbf{Zdrojový kód vyhledávání v jazyku Java:}

\begin{kicode}{Java}{kod:searchBinary}{search - funkce vyhledávání v BVS}
Node search(int value, Node node) { //value je hledaná hodnota, node je při prvním volání kořen
	if (node == null) {
		return null; //uzel nebyl nalezen
	}
	
	if (value > node.getValue()) {//pokud je hledaná hodnota vyšší než má aktuální uzel
		search(value, node.getRight());//nastavím uzel na pravého potomka
	} else if (value < node.getValue()) { //pokud je hledaná hodnota vyšší než má aktuální uzel
		search(value, node.getLeft()); //nastavím uzel na levého potomka
	} else { //pokud není vyšší ani nižší, tak se musí rovnat
		return node; //vrátím nalezený uzel
	}
}
\end{kicode}


\newpage
\subsubsection{Vkládání}
\indent\indent Při \textit{vkládání} zadané hodnoty $x$ je nejprve nutné prohledat strom, jestli se zde $x$ již nenachází. Pokud je nalezen uzel s hodnotou $x$, je výsledkem operace nalezený uzel. V případě, že daný strom tento uzel neobsahuje, je jako potomek posledního prohledávaného uzlu vložen nový uzel s hodnotou $x$. \\


\noindent \textbf{Přesný postup vkládání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Na začátku vkládání je třeba určit aktuální uzel, který označíme $u$. Vkládanou hodnotu označíme $x$.\\
V tomto kroku $u$ bude kořen stromu. Pokud strom nemá kořen, vytvoříme nový uzel s hodnotou $x$ a ten vložíme do stromu. Uzel se stane kořenem stromu, čímž vkládání končí.
{\bfseries\item  krok} -- vyhledávání, vkládání \\
Před vkládáním je nejprve nutno ověřit, zda se ve stromu nenachází uzel s hodnotou $x$.\\\\
\textbf{Vyhledávání může dopadnout těmito způsoby:}
\begin{itemize}
\item Prvek byl nalezen. \\
Pokud byl uzel s hodnotou $x$ nalezen, vkládání končí neúspěchem.
\item Prvek nebyl nalezen, přičemž platí $x > u.h$\footnote{\label{hodnotaPosledniho}Hodnota posledního navštíveného uzlu při hledání.}.\\
Vytvoříme nový uzel s hodnotou $x$ a vložíme jako pravého potomka $u$\footnote{\label{posledni}Poslední navštívený uzel při hledání.}.
\item Prvek nebyl nalezen, přičemž platí $x < u.h$\footnoteref{hodnotaPosledniho}.\\
Vytvoříme nový uzel s hodnotou $x$ a vložíme jako levého potomka $u$\footnoteref{posledni}.
\end{itemize}
\end{enumerate}

\medskip
\noindent Na obrázku \ref{binarySearchInsert} je zvýrazněna cesta průchodů stromem při vyhledávání uzlu s hodnotou 6. Samotné vložení je na obrázku \ref{binaryInsert}.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.9]{obrazky/6BinarniVkladani1.png}
	\caption{BVS - postup vkládání hodnoty 6 -- hledání}
	\label{binarySearchInsert}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.9]{obrazky/6BinarniVkladani2.png}
	\caption{BVS - postup vkládání hodnoty 6 -- vložení}
	\label{binaryInsert}
\end{figure}

\newpage
\noindent \textbf{Zdrojový kód vkládání v jazyku Java:}\\\\
\noindent Před samotnou funkcí \kiinlinecode{Java}{!}{insert} je třeba vytvořit třídu \kiinlinecode{Java}{!}{Result}, která bude dále použita:
\begin{kicode}{Java}{}{Result - třída pro reprezentaci výsledku}
Class Result() {
	private Node node; //poslední navštívený uzel (hledaný/rodič)
	private boolean isFind; //atribut pro určení zda byl uzel nalezen
	
	public Result(Node node, boolean isFind) { //konstruktor
		...
	}	
	...
}
\end{kicode}

\newpage
\noindent Dále je potřeba trochu poupravit již známou funkci \kiinlinecode{Java}{!}{search} \ref{kod:searchBinary}:

\begin{kicode}{Java}{}{search - úprava funkce vyhledávání s použitím Result}
Result search(int value, Node node) { //value je hledaná hodnota, node je při prvním volání kořen	
	if (value > node.getValue()) { 
		if (node.getRight() != null) { 
			search(value, node.getRight()); //pokud má pravého potomka
		} else {
			return new Result(node, false); //pokud nemá pravého potomka, node = rodič vkládaného
		}
	} else if (value < node.getValue()) { 
		if (node.getLeft() != null) {
			search(value, node.getLeft()); //pokud má levého potomka
		} else {
			return new Result(node, false); //pokud nemá levého potomka, node = rodič vkládaného
		} 
	} else { 
		return new Result(node, true); 
	}
}
\end{kicode}

\noindent Nyní funkce \kiinlinecode{Java}{!}{insert}:

\begin{kicode}{Java}{}{insert - funkce vkládání v BVS}
Node insert(int value) {
	Result result = search(value); //nejprve vyhledáme value		
	if (result.isFind()) { //pokud byl uzel s danou hodnotou nalezen
		return result.getNode();
	} else { //dále vkládáme nově vytvořený uzel: 
		if (value > result.getNode().getValue()) {
			result.getNode().setRight(new Node(value));//bude pravý potomek
		} else { 
			result.getNode().setLeft(new Node(value));//bude levý potomek
		}
	}
	return null;
\end{kicode}

\newpage
\subsubsection{Odebírání}
\indent\indent Při \textit{odebírání} zadané hodnoty $x$ je stejně jako u vkládání nejprve nutné prohledat strom, zda se odebíraný uzel s hodnotou $x$ ve stromě nachází. Pokud je uzel nalezen, je následně smazán a struktura stromu případně upravena.\\

\noindent \textbf{Přesný postup odebírání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Na začátku odebírání je třeba určit aktuální uzel, který označíme $u$. Odebíranou hodnotu označíme $x$.\\
V tomto kroku $u$ bude kořen stromu. Pokud strom nemá kořen odebírání končí, uzel s hodnotou $x$ nebyl nalezen.
{\bfseries\item  krok} -- vyhledávání \\
Před odebíráním je nejprve nutno uzel s hodnotou $x$ vyhledat.\\\\
\textbf{Vyhledávání může dopadnout těmito způsoby:}
\begin{itemize}
\item Prvek nebyl nalezen. \\
Pokud se uzel s hodnotou $x$ ve stromě nenachází, odebírání končí neúspěchem.
\item Prvek byl nalezen. \\
Nyní můžeme nalezený uzel $u$ odebrat.
\end{itemize}
{\bfseries\item  krok} -- odebírání \\\\
\textbf{Odebírání $u$ má tyto možnosti:}
\begin{itemize}
\item Pokud $u$ je list\footnote{Nemá žádné potomky.}. \\
List $u$ může být odebrán.
\item $u$ má jednoho potomka. \\
$u$ bude nahrazen podstromem potomka.
\item $u$ má dva potomky. 
\begin{itemize}
\item $u$ bude nahrazen \textit{nejlevějším} prvkem z \textit{pravého} podstromu.
\item $u$ bude nahrazen \textit{nejpravějším} prvkem z \textit{levého} podstromu.
\end{itemize}
\end{itemize}
\end{enumerate}

\medskip
\noindent V následujícím obrázku \ref{binaryDelete} je ukázka mazání uzlu s hodnotou 4, který je následně nahrazen uzlem s hodnotou 5, který je \textit{nejlevější} prvek z \textit{pravého} podstromu.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.7]{obrazky/7BinarniMazani.png}
	\caption{BVS - postup odebírání hodnoty 4}
	\label{binaryDelete}
\end{figure}

\newpage\noindent \textbf{Zdrojový kód\footnote{Tento kód je pouze zjednodušená implementace k lepšímu pochopení odebírání.} odebírání v jazyku Java:}\\\\

\begin{kicode}{Java}{}{delete - funkce pro odebírání v BVS}
boolean delete(int value) {
	Node removeNode = result.getNode();
	Node helpNode; //pomocná proměnná
	
	Result result = search(value); //vyhledám hodnotu
	
	if (!result.isFind()) {  //pokud ho nenajdu
		return false;
	}	
	
	if ((removedNode.getLeft() != null) && (removedNode.getRight() != null)) { //Pokud má dva potomky 
		helpNode = removeNode.getRight(); //dosadím pravého potomka	
			
		while (helpNode.getLeft() != null) { //a hledám nejlevějšího
			helpNode = helpNode.getLeft();
		}
		
		removeNode.setNode(helpNode);
	} else if (removedNode.getLeft() != null) { //pouze levý potomek
		removeNode.setNode(removedNode.getLeft());
	} else if (removedNode.getRight() != null) { //pouze pravý potomek
		removeNode.setNode(removedNode.getRight());
	} else { //pokud je to list   
		removeNode.delete(); //odstraním list ze stromu
	}        
	
	return true; 
}
\end{kicode} 

\newpage
\subsection{AVL strom}
\indent\indent Určitým způsobem by se dalo tvrdit, že \textit{AVL strom} je binární vyhledávací strom, který má ale jednu zásadní odlišnost. Složitost všech operací u BVS je závislá na výšce stromu, je tedy žádoucí udržovat výšku stromu co nejnižší. \textit{AVL strom} je tedy vyvážený binární vyhledávací strom. \\

\begin{definition}[Vyvážený strom]
Strom je vyvážený tehdy a jen tehdy, je-li rozdíl výšek každého uzlu nejvýše 1.\cite{Adelson}\cite{dvorsky}
\end{definition}

\noindent Kvůli udržování vyváženosti stromu mají operace \textit{vkládání} a \textit{odebírání} složitost $\theta(log (n))$.\\
\newpage
\noindent V následujícím obrázku \ref{vyvazenyStrom} je předchozí definice o vyváženém stromu názorně vysvětlena. Nejprve je třeba zavést pojmy:
\begin{itemize}
\item $u$ -- aktuální uzel.
\item $L$ -- levý podstrom $u$.
\item $P$ -- pravý podstrom $u$.
\item $h_L$ -- výška levého podstromu.
\item $h_P$ -- výška pravého podstromu.
\end{itemize}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.3]{obrazky/8AVLVyvazenyStrom.png}
	\caption{Vlastnosti vyváženého stromu}
	\label{vyvazenyStrom}
\end{figure}

\noindent\textbf{Faktor vyvážení}\\
\indent Pro kontrolu dodržení pravidla o vyvážení je třeba pro každý uzel zavést novou vlastnost \textit{faktor vyvážení uzlu}. Tuto vlastnost budeme značit $b$ (anglicky balance). $b$ obsahuje informaci o aktuálním vyvážení daného podstromu.\\ 
\indent Nabývá hodnot <-2, 2>, přičemž uzel je vyvážený pokud jeho faktor $b$ je 1, 0 nebo -1. Při operaci přidávání nebo odebírání může být $b$ rovno 2 nebo -2, pak je ale nutné provést transformaci, která dosáhne vyvážení daného uzlu.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.3]{obrazky/9AVLFaktor.png}
	\caption{Výpočet faktoru vyvážení pro uzel $u$}
\end{figure}

\newpage\noindent \textbf{Zdrojový kód rekurzivního výpočtu faktoru v jazyku Java:}

\begin{kicode}{Java}{computeFactor}{computeFactor - funkce pro výpočet faktoru vyvážení v AVL stromu}
int computeFactor() {		
	int lHeight = 0; //výška levého podstromu
	int rHeight = 0; //výška pravého podstromu
		
	if (left != null) { //pokud má levý podstrom
		lHeight = left.computeFactor();
	}
		
	if (right != null) { //pokud má pravý podstrom
		rHeight = right.computeFactor();
	}		
		
	factor = lHeight - rHeight; 
		
	return Math.max(rHeight, lHeight) + 1;		
}
\end{kicode} 

\begin{figure}[h!]
\centering
	\includegraphics[scale=1]{obrazky/10AVLUkazka.png}
	\caption{Ukázka vyváženého AVL stromu}
\end{figure}


\noindent\textbf{Každý uzel ALV stromu obsahuje tyto vlastnosti:}
\begin{itemize}
\item \textbf{Klíč} -- Hodnota uložená v uzlu.
\item \textbf{Faktor vyvážení} -- Faktor vyvážení daného uzlu.
\item \textbf{Ukazatel na levého potomka}
\item \textbf{Ukazatel na pravého potomka}
\item \textbf{Ukazatel na jednoho rodiče}
\end{itemize}

\subsubsection{Rotace}
\indent\indent K obnově vyváženosti uzlů se používají \textit{rotace}. \textit{Rotace} pouze změní ukazatele uzlů v nevyvážené části stromu, aby došlo k opětovnému vyvážení. V AVL stromu se k vyvažování podle typu nevyvážené části stromu používají tyto rotace:\\

\noindent\textbf{Jednoduchá rotace RR}\\
\noindent Nevyvážený uzel má $b = 2$, jeho \textit{levý potomek} má $b = 0$ nebo $b = 1$.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/11RR.png}
	\caption{AVL - jednoduchá rotace RR}
\end{figure}

\noindent\textbf{Jednoduchá rotace LL}\\
\noindent Nevyvážený uzel má $b = -2$, jeho \textit{pravý potomek} má $b = -1$ nebo $b = 0$.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/12LL.png}
	\caption{AVL - jednoduchá rotace LL}
\end{figure}

\newpage
\noindent\textbf{Dvojitá rotace RL}\\
\noindent Nevyvážený uzel má $b = 2$, jeho \textit{levý potomek} má $b = 1$.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/13RL.png}
	\caption{AVL - dvojitá rotace RL}
\end{figure}

\noindent\textbf{Dvojitá rotace LR}\\
\noindent Nevyvážený uzel má $b = -2$, jeho \textit{pravý potomek} má $b = 1$.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/14LR.png}
	\caption{AVL - dvojitá rotace LR}
\end{figure}

\subsubsection{Vyhledávání}
\indent\indent \textit{Vyhledávání} u AVL stromu se nijak neliší od toho v BVS.

\subsubsection{Vkládání}
\indent\indent \textit{Vkládání} je založeno na \textit{vkládání} u BVS. Navíc je zde přidán krok aktualizace faktoru vyvážení, kde od nově vloženého uzlu postupně u určitých uzlů přepočítáváme $b$. Pokud se strom kvůli vložení nového uzlu stává nevyváženým, provedeme jednu z rotací, čímž daný strom vyvážíme.\\

\newpage
\noindent \textbf{Přesný postup vkládání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Stejně jako u BVS.
{\bfseries\item  krok} -- vyhledávání, vkládání \\
Novému uzlu po vložení nastavíme faktor vyvážení na 0 a $u$ nastavíme na předchůdce nově vloženého uzlu.\\
Pokud nově vložený uzel je kořen, vkládání úspěšně končí.
{\bfseries\item  krok} -- výpočet faktoru vyvážení \\
V tomto kroku v aktuálním uzlu $u$ aktualizujeme faktor vyvážení $b$.\\\\
\textbf{Po aktualizaci $u.b$ mohou nastat tyto případy:}
\begin{itemize}
\item $u.b = 1$ nebo $u.b = -1$\\
Pokud $u$ je kořen, vkládání úspěšně končí. Jinak $u$ nastavíme na rodiče $u$ a znovu opakujeme krok 3.
\item $u.b = 2$ nebo $u.b = -2$\\
Provede se příslušná rotace.\\
Pokud po provedení rotace je $u.b = 0$ nebo je nyní $u$ kořen, vkládání úspěšně končí. Jinak $u$ nastavíme na předchůdce $u$ a znovu opakujeme krok 3.
\item $u.b = 0$\\
Vkládaní úspěšně končí.
\end{itemize}
\end{enumerate}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.55]{obrazky/15AVLVlozeni.png}
	\caption{AVL - postup vkládání hodnoty 5}
\end{figure}

\subsubsection{Odebírání}
\indent\indent \textit{Odebírání} je založeno na stejnojmenné operaci u BVS. Navíc je zde jako u \textit{vkládání} přidán krok aktualizace faktoru vyvážení, kde od odstraněného uzlu postupně u určitých uzlů přepočítáváme $b$. Pokud se strom kvůli odebrání uzlu stává nevyváženým, tak provedeme jednu z rotací, čímž daný strom vyvážíme. 

\newpage
\noindent \textbf{Přesný postup odebírání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Stejně jako u BVS.
{\bfseries\item  krok} -- vyhledávání \\
Stejně jako u BVS.
{\bfseries\item  krok} -- odebírání \\\\
\textbf{Odebírání $u$ má tyto možnosti:}
\begin{itemize}
\item Pokud $u$ je list. \\
List $u$ může být odebrán. \\
Pokud byl $u$ kořen, odebírání úspěšně končí. Jinak nastavíme $u$ na rodiče $u$.
\item $u$ má jednoho potomka. \\
$u$ bude nahrazen podstromem potomka.
Pokud byl $u$ kořen, odebírání úspěšně končí. Jinak nastavíme $u$ na rodiče $u$.
\item $u$ má dva potomky. 
\begin{itemize}
\item $u$ bude nahrazen \textit{nejlevějším} prvkem z \textit{pravého} podstromu, zároveň tento prvek získá faktor vyvážení z $u$.
\item $u$ bude nahrazen \textit{nejpravějším} prvkem z \textit{levého} podstromu, zároveň tento prvek získá faktor vyvážení z $u$.
\end{itemize}
Rodiče uzlu, který nahradil $u$, uložíme do $u$.
\end{itemize}
{\bfseries\item  krok} -- výpočet faktoru vyvážení \\
V tomto kroku v aktuálním uzlu $u$ aktualizujeme faktor vyvážení $b$.\\\\
\textbf{Po aktualizaci $u.b$ mohou nastat tyto případy:}
\begin{itemize}
\item $u.b = <-1,1>$\\
Pokud $u$ je kořen, odebírání úspěšně končí. Jinak $u$ nastavíme na rodiče $u$ a znovu opakujeme krok 4.
\item $u.b = 2$ nebo $u.b = -2$\\
Provede se příslušná rotace.\\
Pokud po provedení rotace je $u.b = 0$ nebo je nyní $u$ kořen, odebírání úspěšně končí. Jinak $u$ nastavíme na předchůdce $u$ a znovu opakujeme krok 4.
\end{itemize}
\end{enumerate}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.55]{obrazky/16AVLOdebirani.png}
	\caption{AVL - postup odebírání hodnoty 1}
\end{figure}

\newpage
\subsection{Červeno-černý strom}
\indent\indent\textit{Červeno-černý strom} (zkratka ČČ) vyvážený BVS. Na rozdíl od AVL stromu je ČČ strom vyvažován na základě barevného označení uzlů. Tímto vyvažováním má časovou složitost operací \textit{vkládání} a \textit{odebírání} $\theta(log (n))$.\\
\indent\textit{\uv{Červeno-černý strom zajišťuje, že žádná cesta z kořene do libovolného listu stromu nebude dvakrát delší než kterákoli jiná, to znamená, že strom je přibližně vyvážený.}}\cite{dvorsky}\\

\noindent\textbf{ČČ strom musí splňovat tyto vlastnosti:}
\begin{itemize}
\item Každý uzel má červenou nebo černou barvu.
\item Kořen stromu má vždy barvu černou.
\item Ve stromu se nenacházejí dva po sobě jdoucí červené uzly.
\item Každý červený uzel, který není list, má dva černé potomky.
\item Cesta od kořene ke všem listům obsahuje vždy stejný počet černých uzlů.\footnote{Je zde započítán i samotný list, pokud má černou barvu.} 
\end{itemize}

\begin{figure}[h!]
\centering
	\includegraphics[scale=1]{obrazky/17CCUkazka.png}
	\caption{Ukázka vyváženého ČČ stromu}
\end{figure}

\newpage
\noindent\textbf{Každý uzel ČČ stromu obsahuje tyto vlastnosti:}
\begin{itemize}
\item \textbf{Klíč} -- Hodnota uložená v uzlu.
\item \textbf{Obarvení uzlu} -- Barva uzlu.
\item \textbf{Ukazatel na levého potomka}
\item \textbf{Ukazatel na pravého potomka}
\item \textbf{Ukazatel na jednoho rodiče}
\end{itemize}

\subsubsection{Transformace}
\indent\indent K obnově vyváženosti uzlů se používají \textit{transformace}. Používají se zde stejně jako u AVL stromu \textit{Rotace} a navíc je zde nová transformace \textit{přebarvení}. Tyto \textit{transformace} se používají k opětovnému vyvážení nevyváženého stromu.\\

\noindent\textbf{Jednoduchá rotace RR}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/18RR.png}
	\caption{ČČ - jednoduchá rotace RR}
\end{figure}

\noindent\textbf{Jednoduchá rotace LL}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/19LL.png}
	\caption{ČČ - jednoduchá LL}
\end{figure}

\newpage
\noindent\textbf{Dvojitá rotace RL}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/20RL.png}
	\caption{ČČ - dvojitá rotace RL}
\end{figure}

\noindent\textbf{Dvojitá rotace LR}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/21LR.png}
	\caption{ČČ - dvojitá rotace LR}
\end{figure}

\noindent\textbf{Přebarvení + symetrické případy}\\
Pokud má ten vyšší z dvojice červených po sobě jdoucích uzlů červeného sourozence, tak on i jeho sourozenec získá černou barvu a jejich rodič, pokud se nejedná o kořen, získá červenou barvu.\\
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/22Prebarveni.png}
	\caption{ČČ - přebarvení 1}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/23Prebarveni.png}
	\caption{ČČ - přebarvení 2}
\end{figure}
\newpage
\subsubsection{Vyhledávání}
\indent\indent \textit{Vyhledávání} u ČČ stromu se nijak neliší od toho v BVS.


\subsubsection{Vkládání}
\indent\indent \textit{Vkládání} je založeno na \textit{vkládání} u BVS. Navíc je zde kvůli vyvážení stromu přidán krok kontroly barev. Pokud se ve stromu po vložení objeví dva po sobě jdoucí uzly s červenou barvou, provedeme příslušné transformace, aby strom splňoval vlastnosti ČČ stromu.\\
\indent Každý nový uzel má při vkládáni automaticky červenou barvu.\\

\noindent \textbf{Přesný postup vkládání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Stejně jako u BVS.
{\bfseries\item  krok} -- vyhledávání, vkládání \\
Vložíme nový uzel $u$ na příslušné místo a $u$ nastavíme na předchůdce tohoto uzlu, je-li nový uzel kořen, nastavíme mu černou barvu a vkládání úspěšně končí.
{\bfseries\item  krok} -- kontrola obarvení stromu \\
Pokud má $u$ černou barvu, vkládání úspěšně končí. Jinak provedeme příslušnou transformaci:
\begin{itemize}
\item Rotaci\\
Po provedení rotace se strom stává vyváženým a vkládání úspěšně končí.
\item Přebarvení\\
Po přebarvení nastavíme $u$ na předchůdce $u$.\\
Pokud je nyní $u$ černý, tak se jedná o kořen a vkládání úspěšně končí. Jinak nastavíme $u$ na rodiče $u$ a znovu provedeme krok 3.
\end{itemize}
\end{enumerate}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.57]{obrazky/24CCVlozeni.png}
	\caption{ČČ - postup vkládání hodnoty 10}
\end{figure}

\subsubsection{Odebírání}
\indent\indent \textit{Odebírání} u ČČ stromu je o trochu složitější než u předchozích stromů. Je to způsobeno tím, že musíme zaručit dodržování počtu a umístění černých uzlů, aby po odstranění byla dále splněna vlastnost: \textit{cesta od kořene ke všem listům obsahuje vždy stejný počet černých uzlů.}\\
\indent U \textit{odebírání} tedy musíme sledovat barvu odebíraného uzlu i těch, které nahrazují odebraný uzel. Pokud odebraný (přesunutý) černý uzel nahradí červený, získá černou barvu a strom zůstává vyvážený. Jinak na jeho původní místo vložíme do stromu \textit{dvojitě obarvený černý uzel s NULL hodnotou}. Tento uzel i samotné \textit{dvojité obarvení} nám značí, že je daný strom nevyvážený a pomocí transformací strom upravíme, aby jsme \textit{NULL uzel} i \textit{dvojité označení} odstranili a tím strom vyvážili.\\

\noindent \textbf{Přesný postup odebírání:}
\begin{enumerate} {\bfseries
\item  krok} -- počáteční \\
Stejně jako u BVS.
{\bfseries\item  krok} -- vyhledávání \\
Stejně jako u BVS.
{\bfseries\item  krok} -- odebírání \\\\
\textbf{Odebírání $u$ má tyto možnosti:}
\begin{itemize}
\item Pokud $u$ je list. \\
List $u$ odebereme.\\
Pokud $u$ neměl černou barvu nebo se jednalo o kořen, odebírání úspěšně končí.
\item $u$ má jednoho potomka. \\
Do $u$ dosadíme hodnotu potomka. Pokud je potomek červený můžeme ho odstranit a odebírání úspěšně končí. Jinak $u$ nastavíme na tohoto potomka a znovu zopakujeme krok 3.
\item $u$ má dva potomky. 
\begin{itemize}
\item do $u$ dosadíme hodnotu z \textit{nejlevějšího} prvku z \textit{pravého} podstromu. Pokud je tento prvek červený, odstraníme ho a odebírání úspěšně končí. Jinak $u$ nastavíme na tento prvek a znovu zopakujeme krok 3.
\item do $u$ dosadíme hodnotu z \textit{nejpravějšího} prvku z \textit{levého} podstromu. Pokud je tento prvek červený, odstraníme ho a odebírání úspěšně končí. Jinak $u$ nastavíme na tento prvek a znovu zopakujeme krok 3.
\end{itemize}
\end{itemize}
{\bfseries\item  krok} -- Odstranění NULL listu \\
V tomto kroku na místo smazaného uzlu $u$ vložíme dvojitě obarvený NULL list. Dále pokračujeme odstraňováním dvojitě obarveného černého uzlu, které je vysvětleno níže.
\end{enumerate}

\newpage
\noindent \textbf{Odstranění dvojitě obarveného černého uzlu:}\\

\noindent \textit{\textbf{Případ 1} -- rotace + symetrické případy:}\\
Pokud má dvojitě obarvený uzel černého sourozence, který má pravého nebo levého potomka červené barvy. Předchůdce dvojitě obarveného uzlu může mít jakoukoliv barvu a tuto barvu pak získá uzel, který se po dokončení rotace dostane na jeho místo.\\\\
V obrázku \ref{pripad1} a \ref{pripad12} může před rotací uzel s hodnotou 8 mít černou barvu. Tuto barvu by po rotaci pak získal uzel s hodnotou 9.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/25Pripad1.png}
	\caption{ČČ - odstranění dvojitě obarveného uzlu -- jednoduchá rotace}
	\label{pripad1}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/26Pripad1_2.png}
	\caption{ČČ - odstranění dvojitě obarveného uzlu -- dvojitá rotace}
	\label{pripad12}
\end{figure}

\newpage
\noindent \textit{\textbf{Případ 2} -- přebarvení + symetrický případ:}\\
Pokud sourozenec dvojitě obarveného uzlu je černý, ale nemá červené potomky a zároveň dvojitě obarvený uzel má červeného předchůdce.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/27Pripad2.png}
	\caption{ČČ - odstranění dvojitě obarveného uzlu -- přebarvení}
\end{figure}\\

\noindent \textit{\textbf{Případ 3} -- přebarvení a přesun označení + symetrický případ:}\\
Pokud sourozenec dvojitě obarveného uzlu je černý, ale nemá červené potomky a zároveň dvojitě obarvený uzel nemá červeného předchůdce.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/28Pripad3.png}
	\caption{ČČ - odstranění dvojitě obarveného uzlu -- přebarvení a přesun označení}
\end{figure}\\
Pokud předchůdce dvojitě obarveného uzlu není kořen, tak získá dvojité obarvení a dále pokračujeme s odstraněním tohoto označení.\\\\

\noindent \textit{\textbf{Případ 4} -- rotace (bez odstranění dvojitě obarveného uzlu) + symetrický případ:}\\
Pokud sourozenec dvojitě obarveného uzlu je červený.
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/29Pripad4.png}
	\caption{ČČ - rotace s dvojitě obarveným uzlem -- jednoduchá rotace}
\end{figure}\\
\newpage
\noindent Po rotaci dále pokračujeme s odstraněním dvojitě obarveného uzlu.\\\\

\noindent \textbf{Ukázka odebírání v ČČ stromu:}
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/30CCMazani.png}
	\caption{ČČ - ukázka odebírání -- 1) odebrání 8}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/31CCMazani.png}
	\caption{ČČ - ukázka odebírání -- 2) vložen NULL list}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/32CCMazani.png}
	\caption{ČČ - ukázka odebírání -- 3) případ 4}
\end{figure}

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/33CCMazani.png}
	\caption{ČČ - ukázka odebírání -- 4) případ 2}
\end{figure}

\newpage
\section{Programátorská dokumentace}
\indent\indent V této kapitole budou popsány technologie, které byly použity pro tvorbu aplikace. Dále zde bude popsána architektura a implementace programu. V této kapitole vycházím ze zdrojů \cite{oracle}, \cite{java} a \cite{javafx}.


\subsection{Programovací jazyk a použité technologie}
\indent\indent Program je napsán v jazyce Java, přesněji ve verzi 8. Na uživatelské prostředí je použita platforma JavaFX. Při výběru vhodného programového jazyka pro tuto aplikaci byla pro mě důležitá zkušenost s tímto jazykem a taky přenositelnost mezi operačními systémy, protože aplikaci jsem psal střídavě ve Windows 10 a macOS 10.13 High Sierra. Pro psaní zdrojového kódu jsem použil vývojové prostředí Eclipse Oxygen.

\subsubsection{Java}
\indent\indent \textit{Java} je objektově orientovaný programovací jazyk, který vznikl v roce 1995. Nyní je nově (od březnu roku 2018) ve verzi 10. Dle \textit{TIOBY indexu} se Java v poslední době nachází stále na 1. místě nejpoužívanějších programovacích jazyků.\cite{tioby} Program v Javě je možné spustit i bez instalace, stačí mít nainstalovanou správnou verzi JVM\footnote{Java Virtual Machine.}.

\subsubsection{JavaFX}
\indent\indent Pro tvorbu grafického uživatelského prostředí (zkratka GUI) aplikace jsem využil \textit{JavaFX}. Je to platforma pro tvorbu GUI v programech Java, která je součástí knihovny Java od verze 8. Nahrazuje zastaralý \textit{Swing}. \textit{JavaFX} navíc umožňuje tvorbu animací a podporuje stylování pomocí CSS\footnote{Cascading Style Sheets.}. 

\subsubsection{FXML}
\indent\indent\textit{FXML} je značkovací jazyk založen na jazyku \textsc{XML}\footnote{Extensible Markup Language.}. Tento jazyk se používá k návrhu GUI v JavaFX.

\subsection{Architektura programu}

\noindent \textbf{Program obsahuje tyto balíky:}
\begin{itemize}
\item application
\item trees
\item graphic
\end{itemize}

\subsubsection{Balík \textit{application}}
\indent\indent Tento balík vytváří a má kontrolu nad GUI. Dále zprostředkovává komunikaci mezi logickou a grafickou částí programu. \\

\noindent \textbf{Seznam souborů v balíku:}
\begin{itemize}
\item \kiinlinecode{Java}{!}{Main}
\item \kiinlinecode{Java}{!}{WindowController}
\item \kiinlinecode{Java}{!}{styles} -- typu CSS
\item \kiinlinecode{Java}{!}{Window} -- typu FXML
\end{itemize}

\smallskip
\noindent \textbf{Třída \textit{Main}}\\
\indent Třída dědí z třídy \kiinlinecode{Java}{!}{Application}, která umožňuje vytvořit JavaFX aplikaci. Tato třída obsahuje funkci \kiinlinecode{Java}{!}{main(String[] args)}, což je hlavní funkce programu, která se spustí hned při spuštění aplikace. Poté se spustí funkce \kiinlinecode{Java}{!}{start(Stage primaryStage)}, která inicializuje GUI.\\

\noindent \textbf{Třída \textit{WindowController}}\\
\indent Tato třída obsluhuje všechny prvky okna vytvořené v FXML. Pomocí anotace \textit{@FXML} získá tato třída reference na prvky GUI. Její hlavní činnost spočívá ve vykonávání metod, které jsou  v souboru \kiinlinecode{Java}{!}{Window.fxml} definovány pro prvky okna. Mezi hlavní metody navázané na prvky okna patří: 

\begin{itemize}
\item \kiinlinecode{Java}{!}{changeTree(ActionEvent event)} -- metoda pro změnu aktuálního stromu, ta volá další funkce, které připraví prostředí pro zvolený strom.

\item \kiinlinecode{Java}{!}{searchNumber()},  \kiinlinecode{Java}{!}{insertNumber()}, \kiinlinecode{Java}{!}{deleteNumber()} \label{zakladniMetody} -- metody pro práci s aktuálním stromem, tyto metody zavolají příslušnou obsluhu aktuálního stromu \kiinlinecode{Java}{!}{tree}, což je objekt typu \kiinlinecode{Java}{!}{ITree} (\ref{ITree}). Tento objekt provede operaci s daným stromem a vrátí výsledek typu \kiinlinecode{Java}{!}{Result} (\ref{Result}). Ten je dále předán příslušné metodě objektu \kiinlinecode{Java}{!}{graphicTree} typu \kiinlinecode{Java}{!}{DrawingTree} (\ref{DrawingTree}).

\item \kiinlinecode{Java}{!}{repeatLastAnimation} -- zaručuje obnovení předchozího stromu a zopakování poslední operace.

\item \kiinlinecode{Java}{!}{dialogNewTree} -- obsluha pro tlačítko \textit{Nový...}, které vyvolá dialog pro možnosti nového stromu.

\item \kiinlinecode{Java}{!}{checkEnableButtons} -- funkce, která aktivuje a deaktivuje tlačítka podle logiky jejich možnosti použití (\textit{např. pokud je aktuální strom prázdný, je deaktivováno tlačítko Vyhledat a Smazat}).
\end{itemize}

\indent Její další činnost spočívá v komunikaci mezi logickou a grafickou částí programu. Což hlavně zajišťují již zmíněné metody: \kiinlinecode{Java}{!}{searchNumber()},  \kiinlinecode{Java}{!}{insertNumber()}, \kiinlinecode{Java}{!}{deleteNumber()}. Navíc jsou zde funkce pro generování náhodného stromu: \kiinlinecode{Java}{!}{newRandomTree()} a \kiinlinecode{Java}{!}{generateRandomTreeList()} nebo pro ukládání předchozího stromu a jeho následné obnovení: \kiinlinecode{Java}{!}{createHistory()}, \kiinlinecode{Java}{!}{createHistoryRecursion(Object object)} (\textit{pomocná metoda pro rekurzivní uložení rozložení hodnot v aktuálním stromu}) a \kiinlinecode{Java}{!}{getHistoryTree()}.\\

\noindent \textbf{Soubor kaskádových stylů \textit{styles}}\\
\indent Obsahuje popis způsobu zobrazování elementů v okně aplikace. Tyto styly jsou zapsány podobně jako CSS styly pro jazyk \textit{HTML}, s tím rozdílem, že se před každou vlastnost známou ze stylování HTML stránek dává prefix -fx- např.:
\begin{kicode}{CSS}{}{styles.css - ukázka zápisu}
.menu-text, Label  {
    -fx-font-size: 14.0pt;
    -fx-font-family: "Segoe UI Light";
    -fx-fill: white;
}
\end{kicode}

\noindent Celá podrobná dokumentace CSS pro JavaFX aplikace je dostupná na adrese: \\
\url{https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html}.\\

\noindent \textbf{Soubor FXML \textit{Window}}\\
\indent V tomto FXML souboru je napsána celá struktura GUI aplikace, která je navázána na příslušný controller \kiinlinecode{Java}{!}{application.WindowController}. Jsou zde na jednotlivé elementy okna navázány příslušné metody pro obsloužení akcí s těmito elementy (\textit{např. pokud uživatel klikne na tlačítko Vložit, je zavolána metoda} \kiinlinecode{Java}{!}{insertNumber()} \textit{z třídy} \kiinlinecode{Java}{!}{WindowController}).\\

\subsubsection{Balík \textit{trees}}
\indent\indent Tento balík se stará o logiku stromů. Jsou zde implementovány všechny stromy a jejich příslušné operace, které byly výše popsány.\\

\noindent \textbf{Seznam souborů v balíku:}
\begin{itemize}
\item \kiinlinecode{Java}{!}{ITree} -- interface\footnote{Rozhraní Java.}
\item \kiinlinecode{Java}{!}{INode} -- interface
\item \kiinlinecode{Java}{!}{BinaryTree}
\item \kiinlinecode{Java}{!}{AVLTree}
\item \kiinlinecode{Java}{!}{RedBlackTree}
\item \kiinlinecode{Java}{!}{BinaryNode}
\item \kiinlinecode{Java}{!}{AVLNode}
\item \kiinlinecode{Java}{!}{RedBlackNode}
\item \kiinlinecode{Java}{!}{RecordOfAnimation}
\item \kiinlinecode{Java}{!}{Result}
\item \kiinlinecode{Java}{!}{AnimatedAction} -- enum\footnote{Výčtový typ Javy.}
\item \kiinlinecode{Java}{!}{Color} -- enum
\item \kiinlinecode{Java}{!}{Side} -- enum
\end{itemize}

\smallskip
\noindent \textbf{Rozhraní \textit{ITree}} \label{ITree}\\
\indent Toto rozhraní zobecňuje práci se stromy, kdy každý typ stromu implementuje toto rozhraní a tím prakticky většina metod nerozlišuje s jakým typem stromu pracuje, ale pouze používá objekt typu \kiinlinecode{Java}{!}{ITree} a volá metody, které mají pro všechny typy stromů stejný název, ale rozdílnou implementaci. Kvůli tomuto rozhraní je zdrojový kód programu velmi zjednodušen a ušetřen o spoustu řádků, které by musely řešit o jaký strom se jedná a teprve potom volat příslušné metody. Například již zmíněné metody třídy \kiinlinecode{Java}{!}{WindowController}: \kiinlinecode{Java}{!}{searchNumber()},  \kiinlinecode{Java}{!}{insertNumber()}, \kiinlinecode{Java}{!}{deleteNumber()} (\ref{zakladniMetody}) pracují pouze s objektem typu \kiinlinecode{Java}{!}{ITree}.\\\\
Hlavní definované metody rozhraní jsou:

\begin{itemize}
\item \kiinlinecode{Java}{!}{search(int value)},  \kiinlinecode{Java}{!}{insert(int value)}, \kiinlinecode{Java}{!}{delete(int value)} -- definice metod pro základní operace se stromy. Metody vrací objekt typu \kiinlinecode{Java}{!}{Result}.

\item \kiinlinecode{Java}{!}{getRoot()} -- metoda vrátí kořen daného stromu typu  \kiinlinecode{Java}{!}{INode}.
\end{itemize}

\noindent \textbf{Třídy \textit{BinaryTree}, \textit{AVLTree}, \textit{RedBlackTree}}\\
\indent Jsou to třídy, které reprezentují typy stromů. Implementují rozhraní \kiinlinecode{Java}{!}{ITree}, což zaručuje, že každá instance těchto tříd obsahuje všechny základní operace. Kvůli rozdílnému fungování těchto stromů musí každá z těchto tříd tyto operace implementovat po svém. \kiinlinecode{Java}{!}{BinaryTree} prakticky implementuje pouze metody definované v rozhraní \kiinlinecode{Java}{!}{ITree}, zatímco \kiinlinecode{Java}{!}{AVLTree} a \kiinlinecode{Java}{!}{RedBlackTree} obsahují metody navíc.\\
\newpage
\noindent Vybrané metody \kiinlinecode{Java}{!}{AVLTree}:
\begin{itemize}
\item \kiinlinecode{Java}{!}{balanceTree(Result result, AVLNode startNode)} -- metoda, která se volá kvůli vyvážení AVL stromu. Tato metoda ověří faktory vyvážení příslušných uzlů, jestliže je strom nevyvážený volá potřebnou rotaci. Metoda vrací objekt typu \kiinlinecode{Java}{!}{Result}.
\item \kiinlinecode{Java}{!}{llBalance(Result result, AVLNode nodeB)},\\
\kiinlinecode{Java}{!}{rrBalance(Result result, AVLNode nodeB)},\\
\kiinlinecode{Java}{!}{lrBalance(Result result, AVLNode nodeC)},\\
\kiinlinecode{Java}{!}{rlBalance(Result result, AVLNode nodeC)} -- metody, které provádí rotace. Vrací objekt typu \kiinlinecode{Java}{!}{Result}.
\end{itemize}

\noindent Vybrané metody \kiinlinecode{Java}{!}{RedBlackTree}:
\begin{itemize}
\item \kiinlinecode{Java}{!}{balanceTree(Result result, RedBlackNode startNode)} -- metoda, která se volá kvůli vyvážení ČČ stromu. V této metodě se ověří vyváženost stromu, případně je zde provedeno přebarvení, pokud je potřeba jsou volány i metody rotace. Metoda vrací objekt typu \kiinlinecode{Java}{!}{Result}.
\item \kiinlinecode{Java}{!}{llBalance(Result result, RedBlackNode nodeB)},\\
\kiinlinecode{Java}{!}{rrBalance(Result result, RedBlackNode nodeB)},\\
\kiinlinecode{Java}{!}{lrBalance(Result result, RedBlackNode nodeC)},\\
\kiinlinecode{Java}{!}{rlBalance(Result result, RedBlackNode nodeC)} -- metody, které provádí rotace  a s tím související přebarvení. Vrací objekt typu \kiinlinecode{Java}{!}{Result}. 
\item \kiinlinecode{Java}{!}{doubleBlack(Result result, RedBlackNode parent, Side side)} -- tato funkce řeší odstranění dvojitě obarvených uzlů, které se mohou vyskytnou při operaci odebírání. Funkce vrací objekt typu \kiinlinecode{Java}{!}{Result}.
\end{itemize}

\noindent \textbf{Rozhraní \textit{INode}}\\
\indent Rozhraní \kiinlinecode{Java}{!}{INode} obsahuje definice všech důležitých \kiinlinecode{Java}{!}{get} a \kiinlinecode{Java}{!}{set} metod, které jsou potřeba k práci s jakýmkoliv uzlem. Je zde definována i metoda \kiinlinecode{Java}{!}{equals(Object obj)}, která slouží k porovnávání uzlů. Toto rozhraní zobecňuje práci s uzly stromů a umožňuje měnit a číst jejich atributy, aniž by muselo být známo o jaký typ stromu, a tedy i uzlu, se jedná.\\

\noindent \textbf{Třídy \textit{BinaryNode}, \textit{AVLNode}, \textit{RedBlackNode}}\\
\indent Reprezentují uzly stejnojmenných stromů. Implementují rozhraní \kiinlinecode{Java}{!}{INode}.\\
\noindent Třídy obsahují tyto atributy:
\begin{itemize}
\item \kiinlinecode{Java}{!}{value} -- číselná hodnota uzlu.
\item \kiinlinecode{Java}{!}{parent} -- ukazatel na rodiče.
\item \kiinlinecode{Java}{!}{left} -- ukazatel na levého potomka.
\item \kiinlinecode{Java}{!}{right} -- ukazatel na pravého potomka.
\item \kiinlinecode{Java}{!}{graphicNode} -- grafická reprezentace uzlu.
\item \kiinlinecode{Java}{!}{factor}(pouze u \kiinlinecode{Java}{!}{AVLNode}) -- číselná hodnota faktoru vyvážení.
\item \kiinlinecode{Java}{!}{color}(pouze u \kiinlinecode{Java}{!}{RedBlackNode}) -- barva uzlu. Reprezentována pomocí výčtového typu \kiinlinecode{Java}{!}{Color}.
\end{itemize}

\noindent Třída \kiinlinecode{Java}{!}{AVLNode} navíc implementuje zmíněnou rekurzivní funkci \kiinlinecode{Java}{!}{computeFactor()} \ref{computeFactor}.\\

\noindent \textbf{Třída \textit{RecordOfAnimation}}\\
\indent Tato třída slouží k zaznamenávání animací, které budou následně zpracovány v grafické části aplikace.\\
\noindent Třída obsahuje tyto atributy: 
\begin{itemize}
\item \kiinlinecode{Java}{!}{action} -- typ animace reprezentovaný výčtovým typem \kiinlinecode{Java}{!}{AnimatedAction}.
\item \kiinlinecode{Java}{!}{node} -- ukazatel na grafický uzel, kterého se daná animace týká. Tato proměnná je typu \kiinlinecode{Java}{!}{IGraphicNode} (\ref{IGraphicNode}).
\item \kiinlinecode{Java}{!}{object} -- pomocná proměnná, která je používána na různé typy objektu podle druhu animace.
\end{itemize}

\noindent \textbf{Třída \textit{Result}} \label{Result}\\
\indent Objekty této třídy jsou používány jako návratové hodnoty všech logických operací se stromy. Tento objekt má v sobě uloženy důležité informace pro následné zpracování všech grafických operací včetně animací. Ve třídě \kiinlinecode{Java}{!}{WindowController}metody:  \kiinlinecode{Java}{!}{searchNumber()},  \kiinlinecode{Java}{!}{insertNumber()}, \kiinlinecode{Java}{!}{deleteNumber()} (\ref{zakladniMetody}) nejprve zavolají příslušnou metodu u aktuálního logického stromu typu \kiinlinecode{Java}{!}{ITree}. Ta vytvoří objekt typu \kiinlinecode{Java}{!}{Result}, do kterého  postupně uloží všechny animace potřebné ke grafickému zobrazení volané operace a tento objekt na závěr vrátí. Tyto metody vrácený výsledek dále předávají objektu typu \kiinlinecode{Java}{!}{DrawingTree} (\ref{DrawingTree}), který strom vykreslí a vykoná příslušné animace.\\
\noindent Třída obsahuje tyto atributy: 
\begin{itemize}
\item \kiinlinecode{Java}{!}{node} -- výsledný uzel dané operace reprezentován pomocí \kiinlinecode{Java}{!}{INode}.
\item \kiinlinecode{Java}{!}{side} -- pozice výsledného uzlu (\textit{při vkládání je to například strana na kterou má být uzel vložen}), která je výčtového typu \kiinlinecode{Java}{!}{Side}. 
\item \kiinlinecode{Java}{!}{way} -- seznam všech navštívených uzlů při provádění dané operace. Je typu \kiinlinecode{Java}{!}{ArrayList<IGraphicNode>}. Využívá se při animování vyhledávání uzlu. 
\item \kiinlinecode{Java}{!}{recordOfAnimations} -- seznam záznamů všech animací. Je typu \kiinlinecode{Java}{!}{ArrayList<RecordOfAnimation>}. 
\end{itemize}

\newpage
\noindent Vybrané metody:
\begin{itemize}
\item \kiinlinecode{Java}{!}{addNodeToWay(IGraphicNode node)} -- přidává do kolekce \kiinlinecode{Java}{!}{way} navštívený uzel.

\item \kiinlinecode{Java}{!}{addAnimation(AnimatedAction action, IGraphicNode node, Object object)} -- metoda, která přidá do \kiinlinecode{Java}{!}{recordOfAnimations} nový záznam animace.
\end{itemize}

\noindent \textbf{Výčtový typ \textit{AnimatedAction}}\\
\indent Obsahuje například hodnoty: \kiinlinecode{Java}{!}{SEARCH, INSERT, DELETE,}\\ \kiinlinecode{Java}{!}{MOVEVALUE, MOVENODE, RR, LL, RL, LR}... a další.\\

\noindent \textbf{Výčtový typ \textit{Color}}\\
\indent Obsahuje hodnoty: \kiinlinecode{Java}{!}{RED, BLACK;}.\\

\noindent \textbf{Výčtový typ \textit{Side}}\\
\indent Obsahuje hodnoty: \kiinlinecode{Java}{!}{LEFT, RIGHT, NONE;}.\\

\subsubsection{Balík \textit{graphic}}
\indent \indent Tento balík se stará o grafické zobrazování stromů, animování všech operací a zobrazování zjednodušeného popisu.\\ 

\noindent \textbf{Seznam souborů v balíku:}
\begin{itemize}
\item \kiinlinecode{Java}{!}{IGraphicNode} -- interface
\item \kiinlinecode{Java}{!}{AVLGraphicNode}
\item \kiinlinecode{Java}{!}{BinaryGraphicNode}
\item \kiinlinecode{Java}{!}{RedBlackGraphicNode}
\item \kiinlinecode{Java}{!}{DrawingTree}
\end{itemize}
\smallskip
\noindent \textbf{Rozhraní \textit{IGraphicNode}} \label{IGraphicNode}\\
\indent Toto rozhraní definuje všechny důležité \kiinlinecode{Java}{!}{get}, \kiinlinecode{Java}{!}{set} a další metody, které jsou potřeba pro práci s jakýmkoliv objektem reprezentující grafický uzel zmíněných stromů. Je ním zobecněna práce třídy \kiinlinecode{Java}{!}{DrawingTree}, která může vykreslovat a provádět animace aniž by znala typ stromu.\\
\indent Objekty typu \kiinlinecode{Java}{!}{IGraphicNode} reprezentují obecný grafických uzel všech stromů a jsou prakticky používány ve všech částech programu. Výjimku tvoří funkce, které jsou specifické pro určitý typ stromu, ty si objekty typu \kiinlinecode{Java}{!}{IGraphicNode} přetypují do \kiinlinecode{Java}{!}{BinaryGraphicNode}, \kiinlinecode{Java}{!}{AVLGraphicNode} nebo \kiinlinecode{Java}{!}{RedBlackGraphicNode} (\textit{Například u AVL stromu je potřeba změnit atribut} \kiinlinecode{Java}{!}{factor} \textit{, který obsahuje a má k němu přístup pouze} \kiinlinecode{Java}{!}{AVLGraphicNode}).\\
\newpage
\noindent Hlavní definované metody jsou:
\begin{itemize}
\item \kiinlinecode{Java}{!}{createStackPaneNode()} -- vytvoří grafickou reprezentaci listu (\textit{vytvoří kruh a doprostřed vloží hodnotu listu, to celé pak vloží do} \kiinlinecode{Java}{!}{StackPane}).
\item \kiinlinecode{Java}{!}{highlightFindNode()} -- metoda pro zvýraznění nalezeného grafického uzlu.
\item \kiinlinecode{Java}{!}{countChildren()} -- metoda, které vypočítá a uloží počet všech pravých a levých potomků daného uzlu. Metoda vrací součet všech potomků. Používá se pro rozpočítání vzdáleností mezi uzly, aby se ve vykresleném stromu žádné nepřekrývaly. Implementace metody je zde \ref{countChildren}.
\end{itemize}

\noindent \textbf{Třída \textit{BinaryGraphicNode}}\\
\indent Třída implementuje rozhraní \kiinlinecode{Java}{!}{IGraphicNode}. Reprezentuje grafický uzel stejnojmenného stromu. Pouze implementuje všechny metody z rozhraní. Obsahuje tyto atributy:
\begin{itemize}
\item \kiinlinecode{Java}{!}{radiusSize} -- velikost vykreslených uzlů. Hodnota je typu \kiinlinecode{Java}{!}{final int} inicializovaná na 20.
\item \kiinlinecode{Java}{!}{parent} -- ukazatel na rodiče uzlu. Typu \kiinlinecode{Java}{!}{IGraphnicNode}.
\item \kiinlinecode{Java}{!}{left} -- ukazatel na levého potomka. Typu \kiinlinecode{Java}{!}{IGraphnicNode}.
\item \kiinlinecode{Java}{!}{right} -- ukazatel na pravého potomka. Typu \kiinlinecode{Java}{!}{IGraphnicNode}.
\item \kiinlinecode{Java}{!}{side} -- pozice vůči rodiči. Výčtového typu \kiinlinecode{Java}{!}{Side}.
\item \kiinlinecode{Java}{!}{leftChildrenCount} -- počet všech levých potomků.
\item \kiinlinecode{Java}{!}{rightChildrenCount} -- počet všech pravých potomků.
\item \kiinlinecode{Java}{!}{value} -- ukazatel na hodnotu uzlu. Typu \kiinlinecode{Java}{!}{Text}.
\item \kiinlinecode{Java}{!}{circle} -- grafický prvek kruh o poloměru \kiinlinecode{Java}{!}{radiusSize}. Typu \kiinlinecode{Java}{!}{Circle}.
\item \kiinlinecode{Java}{!}{stacPaneNode} -- \kiinlinecode{Java}{!}{StackPane}, který představuje grafický uzel. V něm je vložen objekt \kiinlinecode{Java}{!}{value} a \kiinlinecode{Java}{!}{circle}.
\item \kiinlinecode{Java}{!}{x} -- souřadnice \kiinlinecode{Java}{!}{stacPaneNode} x. Typu \kiinlinecode{Java}{!}{DoubleProperty}.
\item \kiinlinecode{Java}{!}{y} -- souřadnice \kiinlinecode{Java}{!}{stacPaneNode} y. Typu \kiinlinecode{Java}{!}{DoubleProperty}.
\item \kiinlinecode{Java}{!}{branch} -- představuje větev\footnote{Spoj mezi uzlem a jeho rodičem.} mezi tímto uzlem a jeho rodičem. Typu \kiinlinecode{Java}{!}{Line}.
\end{itemize}

\begin{kicode}{Java}{countChildren}{countChildren() - rekurzivní funkce pro určení počtu potomků}
@Override
public int countChildren() {
	if (left != null) {
		leftChildrenCount = 1 + left.countChildren();
	} else {
		leftChildrenCount = 0;
	}

	if (right != null) {
		rightChildrenCount = 1 + right.countChildren();
	} else {
		rightChildrenCount = 0;
	}
		
	return leftChildrenCount + rightChildrenCount;
}
\end{kicode}

\newpage
\noindent \textbf{Třídy \textit{AVLGraphicNode} a \textit{RedBlackGraphicNode}}\\
\indent Tyto třídy dědí ze třídy \kiinlinecode{Java}{!}{BinaryGraphicNode} $=>$ zároveň pro ně automaticky platí, že implementují rozhraní \kiinlinecode{Java}{!}{IGraphicNode}. Tyto třídy reprezentují grafické uzly svých stejnojmenných stromů, ale prakticky se od \kiinlinecode{Java}{!}{BinaryGraphicNode} příliš neliší. \\
\indent \kiinlinecode{Java}{!}{AVLGraphicNode} pouze přidává atribut \kiinlinecode{Java}{!}{factor} a k němu příslušnou \kiinlinecode{Java}{!}{get} a \kiinlinecode{Java}{!}{set} metodu. Faktor vyvážení je reprezentován objektem typu \kiinlinecode{Java}{!}{Text}. Tento atribut následně vloží do zděděného atributu \kiinlinecode{Java}{!}{stackNode}.\\ 
\indent \kiinlinecode{Java}{!}{RedBlackGraphicNode} používá červenou a černou barvu výplně zděděného atributu \kiinlinecode{Java}{!}{circle}, kvůli tomu je přidán atribut \kiinlinecode{Java}{!}{color} výčtového typu \kiinlinecode{Java}{!}{Color} a jeho příslušnou \kiinlinecode{Java}{!}{get} a \kiinlinecode{Java}{!}{set} metodu. Dále přidává metodu pro označení dvojitě obarveného listu.\\

\noindent \textbf{Třída \textit{DrawingTree}} \label{DrawingTree}\\
\indent Nejrozsáhlejší třída aplikace, která ovládá grafické zobrazování všech stromů, animací a zobrazování popisku aktuálně prováděných operací. \kiinlinecode{Java}{!}{WindowController} při vytvoření nového stromu vytvoří objekt \kiinlinecode{Java}{!}{graphicTree}, který je instancí \kiinlinecode{Java}{!}{DrawingTree}. Objektu \kiinlinecode{Java}{!}{graphicTree} jsou pak pomocí metod předávány výsledky (typu \kiinlinecode{Java}{!}{Result}) zpracovaných operací v logické reprezentaci stromu. Tyto výsledky jsou následně graficky zpracovány a po provedení poslední animace je program připraven na přijímání dalších požadavků od uživatele.\\

\noindent Parametry konstruktoru:
\begin{enumerate}
\item \kiinlinecode{Java}{!}{paneTree} -- ukazatel na prvek okna typu \kiinlinecode{Java}{!}{Pane}, do kterého se stromy budou kreslit.
\item \kiinlinecode{Java}{!}{animationSpeed} -- ukazatel na \kiinlinecode{Java}{!}{property}\footnote{Vlastnost objektu v JavaFX, které lze \textit{naslouchat} a reagovat na změny. Tyto vlastnosti jsou obvykle typovány na typ objektu, který uchovávají např. \kiinlinecode{Java}{!}{DoubleProperty}. Jdou propojit (\textit{nabindovat}) s jinými property stejného typu $=>$ pokud se změní hodnota v property, tak se změní i hodnota ve všech, které jsou s ní propojeny.} prvku okna typu \kiinlinecode{Java}{!}{Slider}. Parametr je typu \kiinlinecode{Java}{!}{DoubleProperty}. Tato hodnota reprezentuje aktuální zvolenou hodnotu uživatelem pomocí \textit{slideru} pro nastavení rychlosti animace.
\item \kiinlinecode{Java}{!}{stageWidthProperty} -- ukazatel na \kiinlinecode{Java}{!}{property} šířku okna aplikace. Je typu \kiinlinecode{Java}{!}{ReadOnlyDoubleProperty}.
\item \kiinlinecode{Java}{!}{stageHeightProperty} -- ukazatel na \kiinlinecode{Java}{!}{property} výšku okna aplikace. Je typu \kiinlinecode{Java}{!}{ReadOnlyDoubleProperty}.
\item \kiinlinecode{Java}{!}{WindowController} -- ukazatel na samotný objekt \kiinlinecode{Java}{!}{windowController}, který tento konstruktor volá. To proto, aby tato třída měla přístup k metodám pro deaktivování prvků okna při průběhu animace. 
\end{enumerate}
\begin{kicode}{Java}{}{Ukázka použití konstruktoru třídy DrawingTree}
g = new DrawingTree(paneTree, sliderSpeed.valueProperty(), window.widthProperty(), window.heightProperty(), this); 
/**
* window - je okno aplikace
* this -  WindowController ve kterém je tento konstruktor volán
*/
\end{kicode}
Třída má spoustu atributů, které jsou hlavně využívány funkcemi týkajících se animací. Animace po skončení automaticky volají funkce, které nemají přístup k lokálně uloženým datům a proto musí pracovat s atributy třídy, ke kterým je přístup ze všech funkcí dané třídy.
\noindent Některé atributy třídy:
\begin{itemize}
\item \kiinlinecode{Java}{!}{value} -- hodnota vložená uživatelem načtená z \kiinlinecode{Java}{!}{TextArea}.
\item \kiinlinecode{Java}{!}{newIGraphicNode} -- ukazatel na nově vkládaný uzel.
\item \kiinlinecode{Java}{!}{graphicNodeSize} -- rozměr grafického uzlu. Při vkládání kořene je do tohoto atributu vložen jeho rozměr.
\item \kiinlinecode{Java}{!}{xAnimatedNode, yAnimatedNode} -- \kiinlinecode{Java}{!}{DoubleProperty} sloužící k ukládání, které jsou dále používány v animacích. 
\item \kiinlinecode{Java}{!}{DOWNMARGIN} -- představuje velikost zobrazené mezery mezi potomkem a rodičem. Je typu \kiinlinecode{Java}{!}{final int} a má hodnotu 40.
\item \kiinlinecode{Java}{!}{listGraphicNodes} -- seznam všech aktuálně zobrazených uzlů. Typu \kiinlinecode{Java}{!}{ArrayList<IGraphicNode>}.
\item \kiinlinecode{Java}{!}{recordOfAnimations} -- seznam aktuálně prováděný animací. Typu \kiinlinecode{Java}{!}{ArrayList<RecordOfAnimation>}.
\item \kiinlinecode{Java}{!}{animationIndex} -- index poslední provedené animace.
\item \kiinlinecode{Java}{!}{wayList} -- aktuální seznam všech navštívených uzlů, pro animování vyhledávání. Typu \kiinlinecode{Java}{!}{ArrayList<IGraphicNode>}.
\item \kiinlinecode{Java}{!}{wayIndex} -- index posledního zvýrazněného uzlu.
\item \kiinlinecode{Java}{!}{balanceIndex} -- index aktuálně kontrolovaného uzlu, používá se ve funkci \kiinlinecode{Java}{!}{balanceTreeNext()}.
\item Dále obsahuje všechny uložené parametry z konstruktoru jako je:\\\kiinlinecode{Java}{!}{paneTree}, \kiinlinecode{Java}{!}{animationSpeed}, \kiinlinecode{Java}{!}{stageWidthProperty}, \kiinlinecode{Java}{!}{stageHeightProperty}, \kiinlinecode{Java}{!}{windowController}.
\end{itemize}

\noindent Vybrané metody:
\begin{itemize}
\item \kiinlinecode{Java}{!}{insertRoot(INode root)} -- metoda animuje vložení kořene. Kvůli skutečnosti, že uživatel může měnit velikost okna aplikace, musí mít kořen souřadnice, které se přizpůsobují aktuální šířce okna. K tomu slouží již zmíněná \kiinlinecode{Java}{!}{stageWidthProperty}. S tímto atributem propojím \kiinlinecode{Java}{!}{x} (\kiinlinecode{Java}{!}{DoubleProperty}) kořene, navíc ji vydělím dvěma, abych pozicoval uzel přímo doprostřed okna. Tím zaručím, že kořen bude vždy uprostřed okna.

\item \kiinlinecode{Java}{!}{insertNode(Result result, int value)} -- metoda je volána z \\\kiinlinecode{Java}{!}{WindowController} při kliknutí uživatele na tlačítko \textit{Vložit}. Nejprve se vkládanému uzlu uloženého v \kiinlinecode{Java}{!}{result} nastaví počáteční souřadnice a je vložen do okna, zároveň je uložen do \kiinlinecode{Java}{!}{newIGraphicNode}. Poté je zavolána metoda \kiinlinecode{Java}{!}{startAnimation(result.getRecordOfAnimations()}.

\item \kiinlinecode{Java}{!}{deleteNode(Result result, int value)} -- pokud je mazaný uzel nalezen volá \kiinlinecode{Java}{!}{startAnimation(result.getRecordOfAnimations()}. Při nenalezení pouze zobrazí animaci hledání. 

\item \kiinlinecode{Java}{!}{searchNode(Result result, int value)} -- připraví prostředí na hledání a zavolá \kiinlinecode{Java}{!}{startAnimation(result.getRecordOfAnimations()}.

\item \kiinlinecode{Java}{!}{startAnimation(ArrayList<RecordOfAnimation> recordOfAnimations)} -- tato funkce pouze připraví prostředí pro spuštění animací. Tato příprava spočívá v nastavení všech potřebných atributů na výchozí hodnoty, určení rychlosti animace, uložení aktuálního seznamu animací, atd.). Dále volá funkci \kiinlinecode{Java}{!}{nextAnimation()}.

\item \kiinlinecode{Java}{!}{nextAnimation()} -- funkce má na starost postupné vykonávání animací ze seznamu \kiinlinecode{Java}{!}{recordOfAnimations}. Obsahuje \kiinlinecode{Java}{!}{switch}, který podle typu animace zavolá příslušnou funkci. Ukázka této funkce naleznete zde \ref{nextAnimation}.

\item \kiinlinecode{Java}{!}{insertNodeAnimation()} -- zde je prováděna animace vkládání nového uzlu. Souřadnice nově umístěného uzlu určím pomocí tohoto kódu \ref{souradnice}. Po dokončení animace je zavolána funkce \kiinlinecode{Java}{!}{insertNodeAnimationFinished()}, která tyto souřadnice uloží do vloženého uzlu a zařídí pokračování dalších animací, tak že navýší \kiinlinecode{Java}{!}{animationIndex} o 1 a zavolá funkci \kiinlinecode{Java}{!}{nextAnimation()}.

\item \kiinlinecode{Java}{!}{createBranch(IGraphicNode node)} -- funkce vytvoří pro daný uzel \textit{větev}, nebo-li hranu mezi tímto uzlem a jeho rodičem.

\item \kiinlinecode{Java}{!}{checkBranches()} -- funkce ověří, zda všechny vykreslené uzly, mají zobrazené příslušné \textit{větve}. Pokud se tam nějaká větev nenachází, tak jí zobrazí. Neobsahuje-li uzel větev, která by se měla zobrazit, tak je nejprve vytvořena a pak i zobrazena.

\item \kiinlinecode{Java}{!}{balanceTree()} a \kiinlinecode{Java}{!}{balanceTreeNext()} -- funkce, která zajišťuje korektní zobrazení stromů. \kiinlinecode{Java}{!}{balanceTree()} je volána při dokončení všech animací. Uvnitř funkce se pomocí rekurzivní funkce \kiinlinecode{Java}{!}{countChildren()} aktualizuje počet potomků u všech uzlů. Pak je zavolána funkce \kiinlinecode{Java}{!}{balanceTree()} a ta pomocí rekurze postupně prochází \kiinlinecode{Java}{!}{listGraphicNodes}. Pro každý uzel vypočítá správné souřadnice a porovná je s aktuálním umístění uzlu. Pokud se souřadnice liší, tak je potřeba uzel posunout na správné místo. Tímto postupem je zaručeno, že se žádný uzel nebude překrývat. Ukázka funkce je zde \ref{balance}.
\item Dále jsou zde implementovány metody na příslušné animace: \\\kiinlinecode{Java}{!}{deleteNodeAnimation()}, \kiinlinecode{Java}{!}{moveNodeAnimation()}, \kiinlinecode{Java}{!}{moveValueAnimation()}, \kiinlinecode{Java}{!}{updateFactor()}, \kiinlinecode{Java}{!}{rrAnimation()}, \kiinlinecode{Java}{!}{rlAnimation()}, \kiinlinecode{Java}{!}{llAnimation()},\\\kiinlinecode{Java}{!}{lrAnimation()}.
\end{itemize}

\begin{kicode}{Java}{souradnice}{Ukázka určení souřadnic nově vloženého uzlu}
DoubleProperty x = new SimpleDoubleProperty();
DoubleProperty y = new SimpleDoubleProperty();

if (result.getSide() == Side.LEFT) {
	x.bind(newIGraphicNode.getParent().getX().subtract(graphicNodeSize));	
} else {
	x.bind(newIGraphicNode.getParent().getX().add(graphicNodeSize));	
}
	
y.bind(newIGraphicNode.getParent().getY().add(DOWNMARGIN));	
newIGraphicNode.setX(x);
newIGraphicNode.setY(y);
\end{kicode}

\begin{kicode}{Java}{nextAnimation}{Zkrácená ukázka nextAnimation()}
private void nextAnimation() {
	//pokud už proběhly všechny animace
	if (animationIndex >= recordOfAnimations.size()) { 
		balanceTree();				
		return;
	}
		
	switch (recordOfAnimations.get(animationIndex).getAction().) {
	case SEARCH:
		wayIndex = 0;
		nextSearchNode();
		break;
			
	case INSERT:
		insertNodeAnimation();
		break;
			
	case DELETE:
		deleteNodeAnimation();			
		break;
			
	case MOVENODE:
		moveNodeAnimation();
		break;	
	...
\end{kicode}



\begin{kicode}{Java}{balance}{Ukázka výpočtu správného umístění uzlu}
xAnimatedNode = new SimpleDoubleProperty();
IGraphicNode iGraphicNode = listGraphicNodes.get(balanceIndex);		

if (iGraphicNode.getSide() == Side.LEFT) {
	xAnimatedNode.bind(iGraphicNode.getParent().getX().subtract(graphicNodeSize).subtract(graphicNodeSize * iGraphicNode.getRightChildrenCount()));
	
} else {
	xAnimatedNode.bind(iGraphicNode.getParent().getX().add(graphicNodeSize).add(graphicNodeSize * iGraphicNode.getLeftChildrenCount()));
}

//pokud uzel nemá správné souřadnice provedu posunutí
if (iGraphicNode.getX().get() != xAnimatedNode.get()) {	
	...
}
\end{kicode}


\clearpage
\section{Uživatelská příručka}
\indent \indent Uživatelská příručka obsahuje návod, který popisuje jak aplikaci spustit a její funkčnost. Jsou zde popsány i všechny komponenty okna a práce s nimi. 

\subsection{Minimální požadavky aplikace}
\begin{itemize}
\item Windows 10 nebo macOS 10.12 Sierra.
\item JVM verze 8.
\item Rozlišení obrazovky aspoň 1366$\times$768.
\end{itemize}

\subsection{Spuštění}
\indent \indent Aplikaci není třeba instalovat. Před samotným spuštěním je pouze potřeba mít nainstalovaný JVM verze 8, který dostupný z adresy: \url{https://java.com/en/download/}. Samotnou aplikaci \textsc{Stromy.jar} stačí zkopírovat z adresáře \texttt{bin/} a spustit.

\subsection{Okno aplikace}
\indent \indent Po spuštění se zobrazí hlavní okno programu viz. obrázek \ref{hlavniOkno}. V titulku okna je název aktuálně zvoleného stromu.

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.5]{obrazky/34Program.png}
	\caption{Hlavní okno programu.}
	\label{hlavniOkno}
\end{figure}

\newpage
\subsubsection{Popis okna aplikace} 
\begin{enumerate}
\item Menu -- slouží k výběru stromu viz. obrázek \ref{menu}. Aktuální strom je v menu zvýrazněn bílou barvou. % Při vybrání stromu se objeví dialogové okno \ref{dialogMenu}. 
Menu skryjeme po kliknutí na položku \textit{Zpět}.\\\\
\noindent Další funkce menu:
\begin{itemize}
\item \textit{Nový} -- Smaže aktuální strom. %, může zobrazit dialogové okno \ref{dialogMenuNovy}.
\item \textit{Načíst...} -- Zobrazí standardní okno pro výběr umístění uloženého souboru \textit{název.tree}.% Načítání může zobrazit dialog \ref{dialogMenuNacist} nebo chybovou hlášku \ref{dialogChyba1}.
\item \textit{Uložit...} -- Zobrazí standardní okno pro výběr umístění a názvu ukládaného souboru. Na dané místo uloží aktuální strom jako \textit{název.tree}.% Ukládání může zobrazit chybovou hlášku \ref{dialogChyba2}. 
\item \textit{Exportovat jako obrázek...} -- Zobrazí standardní okno pro výběr umístění a názvu obrázku. Na dané místo uloží obrázek aktuálního stromu jako \textit{název.png}.
\item \textit{Ukončit} -- Ukončí aplikaci.
\end{itemize}

\item Textové pole -- pro uživatelské zadávání číselných hodnot. Rozmezí čísla je 0 až 10 000. Při zadání čísla se automaticky tlačítka, které je možné v daném případě použít stávají aktivními. 
\item Tlačítko \textit{Vložit} -- slouží ke vkládání uživatelem zadané hodnoty do aktuálního zobrazeného stromu. Je aktivní vždy, pokud uživatel zadá nějakou hodnotu.
\item Tlačítko \textit{Hledat} -- slouží k hledání uživatelem zadané hodnoty v aktuálním zobrazeném stromu. Je aktivní, pokud strom má alespoň kořen a textové pole obsahuje nějakou uživatelem zadanou hodnotu.
\item Tlačítko \textit{Smazat} -- slouží k odebírání uzlu s uživatelem zadanou hodnotou v aktuálně zobrazeném stromu. Je aktivní, pokud strom má alespoň kořen a textové pole obsahuje nějakou uživatelem zadanou hodnotu
\item Tlačítko \textit{Nový...} -- po kliknutí zobrazí dialog \ref{dialogNovy}. V tomto dialogu je možno aktuální strom vymazat nebo vytvořit náhodný strom. Při výběru \textit{Nový náhodný...} se zobrazí dialog \ref{dialogNahodny}, kde zadáme počet hodnot ve stromě a po potvrzení je strom vytvořen.
\item Kreslící plocha -- zde je vykreslován strom, jsou zde i prováděny animace.
\item Popis operací -- stručný popis aktuálně prováděných operací, který si lze pročíst i po provedení animace. Tento popis lze přesunout, pomocí chytnutí šedého okraje, kamkoliv po kreslící ploše programu. 
\item Rychlost animací -- před prováděním animace, lze vybrat její rychlost, případně i animace vypnout. 
\item Tlačítko \textit{Opakuj poslední krok} -- po kliknutí na tlačítko se zopakuje poslední provedená operace. Toto tlačítko je aktivní, pokud je uložená nějaká předchozí operace.
\end{enumerate}

\begin{figure}[h!]
\centering
	\includegraphics[scale=1]{obrazky/35Menu.png}
	\caption{Menu programu.}
	\label{menu}
\end{figure}

\newpage \noindent Dialogové okna aplikace:
%\begin{figure}[h!]
%\centering
%	\includegraphics[scale=0.8]{obrazky/37Dialog2.png}
%	\caption{Dialogové okno při změně stromu.}
%	\label{dialogMenu}
%\end{figure}
%
%\begin{figure}[h!]
%\centering
%	\includegraphics[scale=0.8]{obrazky/38Dialog4.png}
%	\caption{Dialogové okno kliknutí na \textit{Nový} v menu.}
%	\label{dialogMenuNovy}
%\end{figure}
%
%\begin{figure}[h!]
%\centering
%	\includegraphics[scale=0.8]{obrazky/41Dialog7.png}
%	\caption{Dialogové okno při načítání stromu.}
%	\label{dialogMenuNacist}
%\end{figure}
%
%\begin{figure}[h!]
%\centering
%	\includegraphics[scale=0.8]{obrazky/39Dialog5}
%	\caption{Chyba při načítání uloženého stromu.}
%	\label{dialogChyba1}
%\end{figure}
%
%\begin{figure}[h!]
%\centering
%	\includegraphics[scale=0.8]{obrazky/40Dialog6.png}
%	\caption{Chyba při ukládání stromu.}
%	\label{dialogChyba2}
%\end{figure}


\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/36Dialog.png}
	\caption{Dialogové okno navázané na tlačítko \textit{Nový...}.}
	\label{dialogNovy}
\end{figure}
								
\begin{figure}[h!]
\centering
	\includegraphics[scale=0.8]{obrazky/38Dialog3.png}
	\caption{Dialogové okno pro náhodný strom.}
	\label{dialogNahodny}
\end{figure}




\FloatBarrier
\subsubsection{Klávesové zkratky}
Při zadávání hodnoty do textového pole, je možné volat operace pomocí klávesových zkratek:
\begin{itemize}
\item \textit{ENTER} -- zavolá operaci \textit{Vložit}.
\item \textit{F} -- zavolá operaci \textit{Hledat}.
\item \textit{DELETE} -- zavolá operaci \textit{Smazat}.
\end{itemize}

%% Závěry práce. V jazyce práce a anglicky. Text pro jiný než
%% nastavený jazyk práce (nepovinným parametrem language makra
%% \documentclass, výchozí český) se zadává použitím makra s uvedením
%% jazyka jako nepovinného parametru.
\begin{kiconclusions}
\indent \indent Výsledkem bakalářské práce je aplikace \textsc{Stromy}, která může sloužit k potřebě výuky \textit{Binárních vyhledávacích}, \textit{AVL} a \textit{červeno-černých stromů}. Aplikace názorně animuje operace \textit{Vyhledávání}, \textit{Vkládání} a \textit{Odebírání}. Tyto operace jsou zároveň stručně popsány, navíc je možnost je znovu zopakovat, což umožňuje lepší pochopení dané operace. Aplikace dále umožňuje ukládat a načítat vytvořené stromy a exportovat je jako obrázek. Tento obrázek se pak dá vytisknout nebo použít v textu studijních materiálů.  \\
\indent Aplikace je naprogramována s důrazem na jednoduchost a obecnost. Toto zobecnění hlavních částí programu umožňuje v budoucnu doprogramovat další typy stromů, aniž by se musela předělávat celá aplikace. \\
\indent Program se dá rozšířit například o datové struktury: \textit{B strom}, \textit{B+ strom}, \textit{2-3-4 strom} a jiné. Další rozšíření bych osobně viděl v tom, že bych přidal podporu pro testování znalostí uživatele na náhodných příkladech stromů, kde by uživatel sám upravoval zobrazený strom na základě programem zadané operace. Tento uživatelem upravený strom by byl následně vyhodnocen, případně zobrazeno správné řešení. Do aplikace by i mohl být přidán seznam všech typů animací, které by byly při výběru zobrazeny. Tyto animace by se týkaly všech možných operací a jejich případů. Například při operaci odebírání by bylo možné si zobrazit odebírání kořene s počtem potomků 0, 1 nebo 2. Přitom u 2 potomků by byly na výběr opět všechny možné situace. Tak by bylo možné si zobrazit všechny druhy animací, bez nutnosti předem vytvořit potřebně vypadající strom. Mezi další vylepšení bych určitě zařadil možnost upravení grafického vzhledu programu. K tomuto bych využil možnosti \textit{JavaFx}, která umožňuje měnit způsob zobrazování elementů okna pomocí kaskádových stylů.

\end{kiconclusions}

\begin{kiconclusions}[english]
\indent \indent The result of this bachelor thesis is the application \textsc{Stromy}, which can be used to teach about \textit{Binary Search}, \textit{AVL} and \textit{Red-Black Trees}. The application displays animations of the operations \textit{Search}, \textit{Insertion}, and \textit{Removal}. These operations are briefly described, there is also a possibility to repeat them again, which allows better understanding of the operation. The application also allows you to save and load created trees and export them as an image. This image can then be printed or used in the text of the study materials.\\
\indent The application is programmed with emphasis on simplicity and generality. This generalization of the major parts of the program allows you to program additional types of trees in the future without having to remodel the entire application.\\
\indent The program can be expanded for example by data structures: \textit{B tree}, \textit{B+ tree}, \textit{2-3-4 tree} and others. I would see another extension myself by adding support for testing user's knowledge on random tree examples where the user would modify the tree displayed by the program's specified operation. This user-modified tree would then be evaluated or the correct solution would be displayed. A list of all the types of animations that would be displayed during selection could be added to the app as well. These animations would cover all possible operations and their cases. For example, in the removal operation, it would be possible to display root removal with 0, 1 or 2 descendants. In the case of 2 offspring, all possible situations could be selected again. This would allow you to view all sorts of animations without the need to pre-create the necessary looking tree. Among other improvements I would certainly have included the possibility to adjust the graphical interface of the program. For this I would use the JavaFx option, which allows you to change the way the window elements are displayed using cascading styles.
\end{kiconclusions}

%% Přílohy obsahu textu práce, za makrem \appendix.
\appendix

%%\section{První příloha}
%%Text první přílohy

%%\section{Druhá příloha}
%%Text druhé přílohy

%% Obsah přiloženého CD/DVD. Poslední příloha. Upravte podle vlastní
%% práce!
\section{Obsah přiloženého CD/DVD} \label{sec:ObsahCD}

\begin{description}

\item[\texttt{bin/}] \hfill \\
  Program \textsc{Stromy}, spustitelné přímo z~CD/DVD. 

\item[\texttt{doc/}] \hfill \\
  Text práce ve formátu PDF, vytvořený s~použitím závazného stylu KI
  PřF UP v~Olomouci pro závěrečné práce, včetně všech příloh,
  a~všechny soubory potřebné pro bezproblémové vygenerování PDF
  dokumentu textu (v~ZIP archivu), tj.~zdrojový text textu, vložené
  obrázky, apod.

\item[\texttt{src/}] \hfill \\
  Kompletní zdrojové kódy programu \textsc{Stromy}.

\item[\texttt{readme.txt}] \hfill \\
  Instrukce pro spuštění programu \textsc{Stromy}, včetně
  všech požadavků pro jeho bezproblémový provoz.

\end{description}

Navíc CD/DVD obsahuje:

\begin{description}
\item[\texttt{literature/}] \hfill \\
  Vybrané položky bibliografie.
\end{description}


%% -------------------------------------------------------------------

%% Sazba volitelného seznamu zkratek, za přílohami.
%\printglossary

%% Sazba povinné bibliografie, za přílohami (případně i za seznamem
%% zkratek). Při použití BibLaTeXu použijte makro
%% \printbibliography. jinak prostředí thebibliography. Ne obojí!

%% Sazba i v textu necitovaných zdrojů, při použití
%% BibLaTeXu. Volitelné.
\nocite{*}
%% Vlastní sazba bibliografie při použití BibLaTeXu.
%% \printbibliography


\newpage


\begin{thebibliography}{99}	

\bibitem{belohlavekALM} \uppercase{BĚlohlávek}, Radim. Algoritmická matematika 2 -- část 1 [online]. 2012-05-15. [cit. 2018-07-07]. Dostupné z: \url{http://belohlavek.inf.upol.cz/vyuka/algoritmicka-matematika-2-1.pdf}

\bibitem{belohlavekVychodil} \uppercase{BĚlohlávek}, Radim; \uppercase{Vychodil}, Vilém. Diskrétní matematika pro informatiky II [online]. 2010-10-16. [cit. 2018-07-07]. Dostupné z: \url{http://belohlavek.inf.upol.cz/vyuka/dm2.pdf}

\bibitem{vecerka} \uppercase{veČerka}, Arnošt. Poznámky k přednáškám z předmětu Algoritmická matematika 2. Univerzita Palackého v Olomouci, 2018.

\bibitem{dvorsky} \uppercase{DvorskÝ}, Jiří. Algoritmy I.[online]. 2007-02-27. [cit. 2018-07-07]. Dostupné z: \url{http://www.cs.vsb.cz/dvorsky/Download/SkriptaAlgoritmy/Algoritmy.pdf}

\bibitem{BinarySearch} \uppercase{Finlayson}, Ian. Binary Search Trees [online]. [cit. 2018-07-07].
Dostupné z: \url{http://ianfinlayson.net/class/cpsc340/notes/20-binary-search-trees}

\bibitem{Adelson} \uppercase{Adelson-Velskii}, G. M.; \uppercase{Landis}, E. M. An algorithm for the organization of information. Soviet Mathematics Doklady, 3:1259–1263, 1962. [online]. [cit. 2018-07-07] Dostupné z: \url{http://professor.ufabc.edu.br/~jesus.mena/courses/mc3305-2q-2015/AED2-10-avl-paper.pdf}

\bibitem{cormen} \uppercase{Cormen}, Thomas H.; \uppercase{Leiserson}, Charles E.; \uppercase{Rivest}, Ronald L.; \uppercase{Stein}, Clifford. Introduction to Algorithms, 978-0-262-03384-8, 1990. [online]. 2011-04-04  [cit. 2018-07-07]. Dostupné z: \url{http://belohlavek.inf.upol.cz/vyuka/Cormen-RB-trees.pdf}

\bibitem{algorithms} \uppercase{Galles}, David. Data Structure Visualizations [online]. [cit. 2018-07-07]
Dostupné z: \url{https://www.cs.usfca.edu/~galles/visualization/Algorithms.html}

\bibitem{oracle} ORACLE Java documentation [online]. [cit. 2018-07-07] Dostupné z: \url{https://docs.oracle.com/javase/8/javase-clienttechnologies.htm}

\bibitem{java} \uppercase{Bloch}, Joshua. Effective Java -- Second Edition, 978-0321356680, 2001.

\bibitem{javafx} \uppercase{Pomalori}, Andreas. JavaFX Programming Cookbook [online]. [cit. 2018-07-07] Dostupné z: \url{https://www.javacodegeeks.com/minibook/javafx-programming-cookbook}

\bibitem{tioby} \uppercase{Tioby} [online]. [cit. 2018-07-07] Dostupné z: \url{https://www.tiobe.com/tiobe-index/}


\end{thebibliography}
%% Bibliografie, včetně sazby, při nepoužití BibLaTeXu.
% \begin{thebibliography}{9}
%\bibitem{kniha2} \uppercase{Hawke}, Paul. NanoHttpd: Light-weight HTTP server designed for embedding in other applications. GitHub [online]. 2014-05-12. [cit. 2014-12-06]. Dostupné z: \url{https://github.com/NanoHttpd/nanohttpd}
%
%\bibitem{jeske13} \uppercase{Jeske}, David; \uppercase{Novák}, Josef. Simple HTTP Server in \csharp: Threaded synchronous HTTP Server abstract class, to respond to HTTP requests. CodeProject: For those who code [online]. 2014-05-24. [cit. 2014-12-06]. Dostupné z: \url{http://www.codeproject.com/Articles/137979/Simple-HTTP-Server-in-C}
%
%\bibitem{uzis2012} \uppercase{ÚSTAV ZDRAVOTNICKÝCH INFORMACÍ A STATISTIKY ČR}. Lékaři, zubní lékaři a farmaceuti 2012 [online]. Praha 2, Palackého náměstí 4: Ústav zdravotnických informací a statistiky ČR, 2012 [cit. 2014-12-06]. ISBN 978-80-7472-089-5. Dostupné z: \url{http://www.uzis.cz/publikace/lekari-zubni-lekari-farmaceuti-2012}



%% Sazba volitelného rejstříku, za bibliografií.
\printindex

\end{document}
